### 1. Two Sum

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, v in enumerate(nums):
            res = target - v
            if res in d:
                return [d[res], i]
            d[v] = i
```

### 2. Add Two Numbers

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        carry = 0
        while l1 or l2:
            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            p.next = ListNode(val % 10)
            if l1: l1 = l1.next
            if l2: l2 = l2.next
            p = p.next
            carry = val // 10
        if carry: p.next = ListNode(carry)
        return dummy.next
```

### 3. Longest Substring Without Repeating Characters

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res, l, d = 0, 0, {}
        for r, v in enumerate(s):
            if v in d:
                l = max(l, d[v] + 1)
            res = max(res, r - l + 1)
            d[v] = r
        return res
```

### 4. Median of Two Sorted Arrays

- https://www.youtube.com/watch?v=LPFhl65R7ww&t=1224s
- https://www.youtube.com/watch?v=q6IEA26hvXc

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        A, B, total = nums1, nums2, len(nums1) + len(nums2)
        half = total // 2
        if len(A) > len(B): A, B = B, A
        lengthA, lengthB = len(A), len(B)
        l, r = 0, lengthA - 1
        while True:
            i = (l + r) // 2
            j = half - i - 2
            leftA = A[i] if i >= 0 else -inf
            rightA = A[i + 1] if i + 1 < lengthA else inf
            leftB = B[j] if j >= 0 else -inf
            rightB = B[j + 1] if j + 1 < lengthB else inf
            if leftA <= rightB and leftB <= rightA:
                if total % 2:
                    return min(rightA, rightB)
                return (max(leftA, leftB) + min(rightA, rightB)) / 2
            elif leftA > rightB:
                r = i - 1
            else:
                l = i + 1
```

### 5. Longest Palindromic Substring

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def subLongestPalindrome(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1: r]

        res = ''
        for i in range(len(s)):
            res = max(res, subLongestPalindrome(i, i), subLongestPalindrome(i, i + 1), key = len)
        return res
```

### 6. Zigzag Conversion

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows ==  1 or numRows >= len(s):
            return s
        bucket, flip, row = [[] for i in range(numRows)], -1, 0
        for c in s:
            bucket[row].append(c)
            if row == numRows - 1 or row == 0:
                flip *= -1
            row += flip
        for i, arr in enumerate(bucket):
            bucket[i] = ''.join(arr)
        return ''.join(bucket)
```

### 7. Reverse Integer

```python
class Solution:
    def reverse(self, x: int) -> int:
        def reversePositiveNum(x):
            res = 0
            while x:
                res = res * 10 + x % 10
                x //= 10
            return res
        res = reversePositiveNum(x) if x > 0 else -reversePositiveNum(-x)
        return res if -2 ** 31 <= res <= 2 ** 31 + 1 else 0
```

### 8. String to Integer (atoi)

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        res, sign, s = '', ['+', '-'], s.strip()
        for i, c in enumerate(s):
            if i == 0 and c in sign or c.isnumeric():
                res += c
            else:
                break
        if not res or res in sign:
            return 0
        return min(max(int(res), -2 ** 31), 2 ** 31 - 1)
```

### 9. Palindrome Number

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        def reversePositiveNum(x):
            res = 0
            while x:
                res = res * 10 + x % 10
                x //= 10
            return res
        return reversePositiveNum(x) == x
```

### 10. Regular Expression Matching

- https://www.youtube.com/watch?v=HAA8mgxlov8

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lengthS, lengthP = len(s), len(p)
        @lru_cache(None)
        def dfs(i, j):
            if i >= lengthS and j >= lengthP:
                return True
            if j >= lengthP:
                return False
            match = i < lengthS and (s[i] == p[j] or p[j] == '.')
            if j + 1 < lengthP and p[j + 1] == '*': # check *, 0 or more
                return dfs(i, j + 2) or (match and dfs(i + 1, j))
            return dfs(i + 1, j + 1) if match else False # check match or not if no *
        return dfs(0, 0)
```

### 11. Container With Most Water

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, res = 0, len(height) - 1, 0
        while l < r:
            res = max(res, min(height[l], height[r]) * (r - l))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return res
```

### 12. Integer to Roman

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
        res = ''
        for i, n in enumerate(numbers):
            res += num // n * symbols[i]
            num %= n
        return res
```

### 13. Roman to Integer

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        res = d[s[0]]
        for i in range(1, len(s)):
            res += d[s[i]]
            if d[s[i]] > d[s[i - 1]]:
                res -= 2 * d[s[i - 1]]
        return res
```

### 14. Longest Common Prefix

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        res = strs[0]
        for item in strs:
            while not item.startswith(res):
                res = res[: -1]
        return res
```

#### Tag: Trie

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True
        
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        trie = Trie()
        for word in strs:
            trie.insert(word)
            
        root = trie.root
        res = ''
        while root:
            if len(root.children) > 1 or root.endOfWord:
                break
            c = list(root.children)[0]
            root = root.children[c]
            res += c
        return res
```

### 15. 3Sum

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res, n = set(), len(nums)
        for i in range(n):
            l, r = i + 1, n - 1
            while l < r:
                three = nums[i] + nums[l] + nums[r]
                if three > 0:
                    r -= 1
                elif three < 0:
                    l += 1
                else:
                    res.add((nums[i], nums[l], nums[r]))
                    l += 1
                    r -= 1
        return res
```

### 16. 3Sum Closest

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        res, n = float('inf'), len(nums)
        nums.sort()
        for i in range(n):
            l, r = i + 1, n - 1
            while l < r:
                three = nums[i] + nums[l] + nums[r]
                if abs(target - three) < abs(target - res):
                    res = three
                if three > target:
                    r -= 1
                else:
                    l += 1
        return res
```

### 17. Letter Combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res = ['']
        for n in digits:
            letters = d[n]
            ans = []
            for item in res:
                for c in letters:
                    ans.append(item + c)
            res = ans
        return res if digits else []
```

### 18. 4Sum

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        s, n = set(), len(nums)
        nums.sort()
        for i in range(n):
            for j in range(i + 1, n):
                l, r = j + 1, n - 1
                while l < r:
                    four = nums[i] + nums[j] + nums[l] + nums[r]
                    if four == target:
                        s.add((nums[i], nums[j], nums[l], nums[r]))
                        l += 1
                        r -= 1
                    elif four < target:
                        l += 1
                    else:
                        r -= 1
        return s
```

### 19. Remove Nth Node From End of List

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = slow = fast = ListNode()
        dummy.next = head
        for i in range(n + 1):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```

### 20. Valid Parentheses

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack, valid = [], ['{}', '[]', '()']
        for c in s:
            if stack and any([c == valid[i][1] and stack[-1] == valid[i][0] for i in range(len(valid))]):
                stack.pop()
            else:
                stack.append(c)
        return not stack
```

### 21. Merge Two Sorted Lists

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        while list1 and list2:
            if list1.val < list2.val:
                p.next = ListNode(list1.val)
                list1 = list1.next
            else:
                p.next = ListNode(list2.val)
                list2 = list2.next
            p = p.next
        p.next = list1 if list1 else list2
        return dummy.next
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack, res = [], []
        def backtrack(open, close):
            if open == close == n:
                res.append(''.join(stack))
                return
            if open < n:
                stack.append('(')
                backtrack(open + 1, close)
                stack.pop()
            if close < open:
                stack.append(')')
                backtrack(open, close + 1)
                stack.pop()
        backtrack(0, 0)
        return res
```

### 23. Merge k Sorted Lists

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        dummy = p = ListNode()
        minHeap = []
        for head in lists:
            while head:
                heappush(minHeap, head.val)
                head = head.next
        while minHeap:
            val = heappop(minHeap)
            p.next = ListNode(val)
            p = p.next
        return dummy.next
```

### 24. Swap Nodes in Pairs

```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = dummy = ListNode(0)
        prev.next, curr = head, head
        total = 0
        while head:
            total += 1
            head = head.next

        def reverseOnePair():
            nxt = curr.next
            curr.next, nxt.next, prev.next = nxt.next, prev.next, nxt
        for i in range(total // 2):
            reverseOnePair()
            prev, curr = curr, curr.next
        return dummy.next
```

### 25. Reverse Nodes in k-Group

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        prev = dummy = ListNode(0)
        prev.next, curr = head, head
        total = 0
        while head:
            total += 1
            head = head.next
            
        def reverseOnePair():
            nxt = curr.next
            curr.next, nxt.next, prev.next = nxt.next, prev.next, nxt
        for i in range(total // k):
            for j in range(k - 1):
                reverseOnePair()
            prev, curr = curr, curr.next
        return dummy.next
```

### 26. Remove Duplicates from Sorted Array

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        k = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[k] = nums[i]
                k += 1
        return k
```

### 27. Remove Element

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k, r = 0, len(nums) - 1
        while k <= r:
            if nums[k] == val:
                nums[k] = nums[r]
                r -= 1
            else:
                k += 1
        return k
```

### 28. Find the Index of the First Occurrence in a String

- Robin Karp: rolling hash

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n, pattern = len(needle), hash(needle)
        for i in range(len(haystack)):
            if hash(haystack[i:i+n]) == pattern:
                return i
        return -1
```

### 29. Divide Two Integers

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        if (dividend == -2 ** 31 and divisor == -1): return 2 ** 31 - 1 # max value overflow
        a, b, res = abs(dividend), abs(divisor), 0
        for x in range(32)[::-1]:
            if (a >> x) - b >= 0: # first: 1010 >> 1 = 101 > 11, second: 100 >> 0 = 100 > 11
                res += 1 << x # first: 0 + 1 << 1 = 2, second: 2 + 1 << 0 = 2 + 1 = 3
                a -= b << x # first: 1010 - 11 << 1 = 10 - 6 = 4, second: 100 - 11 << 0 = 100 - 11 = 1, stop
        return res if (dividend > 0) == (divisor > 0) else -res
```

### 30. Substring with Concatenation of All Words

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        ans, n, m, words  = [], len(words), len(words[0]), Counter(words)
        for i in range(len(s) - n * m + 1):
            tmp, cnt = Counter(), 0
            for j in range(i, i + n * m, m):
                w = s[j: j + m]
                if w in words:
                    tmp[w] += 1
                    cnt += 1
                    if tmp[w] > words[w]: 
                        break
                    if cnt == n:
                        ans.append(i)
        return ans
```

### 32. Longest Valid Parentheses

https://www.youtube.com/watch?v=q56S5NIqjdE

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack, res = [-1], 0 # edge cases of s = "()"
        for i in range(len(s)):
            if s[i] == "(": # prepare for finding the max
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])
        return res
```

### 33. Search in Rotated Sorted Array

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return m
            if nums[m] >= nums[l]:
                if (nums[l] <= target < nums[m]):
                    r = m - 1
                else:
                    l = m + 1
            else:
                if (nums[m] < target <= nums[r]):
                    l = m + 1
                else:
                    r = m - 1
        return -1
```
### 34. Find First and Last Position of Element in Sorted Array

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        def binary_right(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > target:
                    r = m - 1
                else:
                    l = m + 1
            return r if r >= 0 and nums[r] == target else -1
        def binary_left(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] < target:
                    l = m + 1
                else:
                    r = m - 1
            return l if l < n and nums[l] == target else -1
        return [binary_left(nums, target), binary_right(nums, target)]
```

### 35. Search Insert Position

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        return bisect_left(nums, target)
```

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] < target:
                l = m + 1
            elif nums[m] > target:
                r = m - 1
            else:
                return m
        return l
```

### 36. Valid Sudoku

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows, cols, squres = defaultdict(set), defaultdict(set), defaultdict(set)
        for r in range(len(board)):
            for c in range(len(board[0])):
                if board[r][c] in (rows[r] | cols[c] | squres[(r // 3, c // 3)]):
                    return False
                if board[r][c] != '.':
                    rows[r].add(board[r][c])
                    cols[c].add(board[r][c])
                    squres[(r // 3, c // 3)].add(board[r][c])
        return True
```

### 37. Sudoku Solver

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols, squares, visit = defaultdict(set), defaultdict(set), defaultdict(set), deque([])
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    squares[(i // 3, j // 3)].add(board[i][j])
                else:
                    visit.append((i,j))

        def dfs():
            if not visit:
                return True

            r, c = visit[0]
            square, numbers = (r // 3, c // 3), {'1','2','3','4','5','6','7','8','9'}
            for n in numbers: # try 9 ways
                if n not in (rows[r] | cols[c] | squares[square]):
                    board[r][c] = n
                    rows[r].add(n)
                    cols[c].add(n)
                    squares[square].add(n)
                    visit.popleft()
                    if dfs(): # find 1 way
                        return True
                    else: # backtrack
                        board[r][c] = "."
                        rows[r].discard(n)
                        cols[c].discard(n)
                        squares[square].discard(n)
                        visit.appendleft((r,c))
            return False # not find
        dfs()
```

### 38. Count and Say

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return '1'
        preString= self.countAndSay(n-1)
        count, res, length = 1, '', len(preString)
        for i in range(length):
            if i < length - 1 and preString[i] == preString[i + 1]:
                count += 1
            else:
                res += str(count) + preString[i]
                count = 1
        return res
```

### 39. Combination Sum

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        def backtrack(curr, ans, idx):
            if curr > target:
                return
            if curr == target:
                res.append(ans)
            for i in range(idx, n):
                backtrack(curr + candidates[i], [candidates[i]] + ans, i)
        backtrack(0, [], 0)
        return res
```

### 40. Combination Sum II

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []
        def backtrack(nums, ans, curr):
            if curr > target:
                return
            if curr == target:
                res.append(ans)
            for i in range(len(nums)):
                if i > 0 and nums[i - 1] == nums[i]:
                    continue
                backtrack(nums[i + 1: ], ans + [nums[i]], curr + nums[i])
        backtrack(candidates, [], 0)
        return res
```

### 41. First Missing Positive

# set
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        s = set(nums)
        for i in range(1, len(nums) + 2):
            if i not in s:
                return i
```

### array index
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        # 3 passes
        n = len(nums)
        for i in range(n): # find negative
            if nums[i] < 0:
                nums[i] = 0
        for i in range(n): # sign positive to negative
            val = abs(nums[i])
            if 1 <= val <= n:
                if nums[val - 1] > 0:
                    nums[val - 1] *= -1
                elif nums[val - 1] == 0: # handle 0, sign to negative out of [1, len(nums)]
                    nums[val - 1] = -1 * (n + 1)
        for i in range(1, n + 1): # find first positive or 0
            if nums[i - 1] >= 0:
                return i
        return len(nums) + 1
```

### 42. Trapping Rain Water

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        l, r, res = 0, len(height) - 1, 0
        leftMax, rightMax = height[l], height[r]
        while l < r:
            if leftMax < rightMax:
                l += 1
                leftMax = max(leftMax, height[l])
                res += leftMax - height[l]
            else:
                r -= 1
                rightMax = max(rightMax, height[r])
                res += rightMax - height[r]
        return res
```

### 43. Multiply Strings

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        def str_to_num(n):
            res = 0
            for i in range(len(n)):
                res = res * 10 + ord(n[i]) - ord('0')
            return res
        res = str_to_num(num1) * str_to_num(num2)
        # convert to string, remember to reverse the result 
        ans = '0' 
        while res:
            ans = (chr(ord('0') + res % 10)) + ans
            res //= 10 
        return ans[:-1] if len(ans) > 1 else ans
```

### 44. Wildcard Matching

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        R, C = len(s), len(p)
        dp = [[False for j in range(C + 1)] for i in range(R + 1)]
        dp[0][0] = True
        for j in range(1, C + 1):
            if p[j - 1] == "*" and dp[0][j - 1]:
                dp[0][j] = True
        
        for i in range(1, R + 1):
            for j in range(1, C + 1):
                if p[j-1] == s[i-1] or p[j-1] == "?":
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == "*":
                    dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i-1][j-1]
        return dp[-1][-1]
```

### 45. Jump Game II

#### sliding window

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        res, l, r = 0, 0, 0
        while r < len(nums) - 1:
            furthest = 0
            for i in range(l, r + 1):
                furthest = max(furthest, nums[i] + i)
            res += 1
            l += 1
            r = furthest
        return res
```

### 46. Permutations

#### backtrack

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, res):
            if not nums:
                res.append(ans[::])
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, res)
                ans.pop()
            return res
        return backtrack(nums, [], [])
```

### 47. Permutations II

### same as: 46
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, s):
            if not nums:
                s.add(tuple(ans[::]))
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, s)
                ans.pop()
            return s
        return backtrack(nums, [], set())
```

### 48. Rotate Image

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, s):
            if not nums:
                s.add(tuple(ans[::]))
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, s)
                ans.pop()
            return s
        return backtrack(nums, [], set())
```

### 49. Group Anagrams

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)
        for s in strs:
            res = ''.join(sorted(list(s)))
            d[res].append(s)
        return list(d.values())
```

### 50. Pow(x, n)

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def helper(x, n):
            if x == 0:
                return 0
            if n == 0:
                return 1
            res = helper(x, n // 2)
            res *= res
            return res * x if n % 2 else res
        res = helper(x, abs(n))
        return res if n >= 0 else 1 / res
```
### 51. N-Queens

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col, posDiag, negDiag = set(), set(), set()
        res, board = [], [['.'] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                res.append([''.join(row) for row in board])
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue
                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = 'Q'
                backtrack(r + 1)
                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = '.'
        backtrack(0)
        return res
```

### 52. N-Queens II

```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        col, posDiag, negDiag = set(), set(), set()
        res, board = 0, [['.'] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                nonlocal res
                res += 1
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue
                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                backtrack(r + 1)
                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
        backtrack(0)
        return res
```

### 53. Maximum Subarray (dp, 978)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp, res = [nums[0]] * n, nums[0]
        for i in range(1, n):
            dp[i] = max(nums[i], dp[i - 1] + nums[i])
            res = max(res, dp[i])
        return res
```

### 54. Spiral Matrix

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res.extend(matrix.pop(0))
            matrix = list(zip(*matrix))[::-1]
        return res
```

### 55. Jump Game

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        res, n = 0, len(nums)
        for i in range(n):
            res = max(res, i + nums[i])
            if res >= n - 1:
                return True
            elif res <= i:
                return False
```

### 56. Merge Intervals (57)

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= res[-1][1]:
                res[-1][1] = max(end, res[-1][1])
            else:
                res.append([start, end])
        return res
```

### 57. Insert Interval (56)

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= res[-1][1]:
                res[-1][1] = max(end, res[-1][1])
            else:
                res.append([start, end])
        return res
```

### 58. Length of Last Word

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        return len(s.split()[-1])
```

### 59. Spiral Matrix II

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        A, lo = [], n*n+1
        while lo > 1:
            lo, hi = lo - len(A), lo
            A = [range(lo, hi)] + list(zip(*A[::-1]))
        return A
```

### 60. Permutation Sequence 

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        res, nums = '', list(range(1, n + 1))
        for i in range(1, n + 1):
            index = 0
            cnt = factorial(n - i)
            while k > cnt:
                index += 1
                k -= cnt
            res += str(nums[index])
            nums.pop(index)
        return res
```

### 61. Rotate List
 
```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head: return head
        #connect tail to head
        cur, length = head, 1
        while cur.next:
            cur = cur.next
            length+=1 
        cur.next = head

        # move to new head
        k = length - (k % length)
        while k > 0:
            cur=cur.next
            k-=1

        #disconnect and return new head
        newhead = cur.next
        cur.next = None
        return newhead
```

### 62. Unique Paths

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # # method 1: dp
        '''
        ROWS, COLS = m, n
        dp = [[1] * COLS for i in range(ROWS)]
        for i in range(1, ROWS):
            for j in range(1, COLS):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
        '''
        
        # method 2: dfs
        '''
        @lru_cache(None)
        def dfs(row, col):
            if row == m or col == n:
                return 0
            if row == m - 1 and col == n - 1:
                return 1
            return dfs(row + 1, col) + dfs(row, col + 1)
        return dfs(0, 0)
        '''

        ### method 3: math
        return factorial(m + n - 2) // (factorial(n - 1) * factorial(m - 1))
```

### 63. Unique Paths II
 
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # method 1: dfs + memo
        '''
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        @lru_cache(None)
        def dfs(row, col):
            if row == m or col == n or obstacleGrid[row][col]:
                return 0
            if row == m - 1 and col == n - 1:
                if obstacleGrid[row][col]:
                    return 0
                return 1
            return dfs(row + 1, col) + dfs(row, col + 1)
        return dfs(0, 0)
        '''
        
        # method 2: dp
        ROWS, COLS = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[1] * COLS for i in range(ROWS)]
        if obstacleGrid[0][0]: return 0
        for j in range(1, COLS):
            dp[0][j] = 0 if obstacleGrid[0][j] else dp[0][j - 1]
        for i in range(1, ROWS):
            dp[i][0] = 0 if obstacleGrid[i][0] else dp[i - 1][0]
        for i in range(1, ROWS):
            for j in range(1, COLS):
                if obstacleGrid[i][j]:
                    dp[i][j] = 0
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

### 64. Minimum Path Sum

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        R, C, first = len(grid), len(grid[0]), grid[0][0]
        # state
        dp = [[first] * C for i in range(R)]
        # init rows
        for j in range(1, C):
            dp[0][j] = dp[0][j - 1] + grid[0][j]
        # init cols
        for i in range(1, R):
            dp[i][0] = dp[i - 1][0] + grid[i][0]
        # top-down
        for i in range(1, R):
            for j in range(1, C):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        return dp[-1][-1]
```

### 65. Valid Number

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        # s = s.strip()
        met_dot = met_e = met_digit = False
        for i, char in enumerate(s):
            if char in ['+', '-']:
                if i > 0 and s[i-1].lower() != 'e':
                    return False
            elif char == '.':
                if met_dot or met_e: return False
                met_dot = True
            elif char.lower() == 'e':
                if met_e or not met_digit:
                    return False
                met_e, met_digit = True, False
            elif char.isdigit():
                met_digit = True
            else:
                return False
        return met_digit
```

### 66. Plus One

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        carry, digits[-1] = 0, digits[-1] + 1
        for i in range(len(digits) - 1, -1, -1):
            res = carry + digits[i]
            digits[i] = res % 10
            carry = res // 10
        return [carry] + digits if carry else digits
```

### 67. Add Binary

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry, i, j, res = 0, len(a) - 1, len(b) - 1, ''
        while i >= 0 or j >= 0:
            ans = carry
            if i >= 0:
                ans += ord(a[i]) - ord('0')
            if j >= 0:
                ans += ord(b[j]) - ord('0')
            i, j = i - 1, j - 1
            carry = 1 if ans > 1 else 0
            res = str(ans % 2) + res
        if carry:
            res = str(carry) + res
        return res
```

### 68. Text Justification

```python
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res, i, width, cur_line = [], 0, 0, []
        while i < len(words):
            cur_word = words[i]
            if width + len(cur_word) <= maxWidth:
                cur_line.append(cur_word)
                width += len(cur_word) + 1
                i += 1
            else:
                spaces = maxWidth - width + len(cur_line) # check how many spaces
                added, j = 0, 0
                while added < spaces: # put the spaces between the words evenly
                    if j >= len(cur_line) - 1:
                        j = 0
                    cur_line[j] += ' '
                    added, j = added + 1, j + 1
                res.append("".join(cur_line))
                cur_line, width = [], 0

        # handle last line
        for word in range(len(cur_line) - 1):
            cur_line[word] += ' '
        cur_line[-1] += ' ' * (maxWidth - width + 1)
        res.append(''.join(cur_line))
        return res
```

### 69. Sqrt(x)

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            m = l + (r - l) // 2
            if m * m < x:
                l = m + 1
            elif m * m > x:
                r = m - 1
            else:
                return m
        return r
```

### 70. Climbing Stairs

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        first, second = 1, 2
        for i in range(3, n + 1):
            second, first = second + first, second
        return second if n >= 2 else first
```

### 71. Simplify Path

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for item in path.split('/'):
            if item in ('', '.'):
                continue
            if item == '..':
                if stack:
                    stack.pop()
            else:
                stack.append(item)
        return '/' + '/'.join(stack)
```

### 72. Edit Distance

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1, len2 = len(word1), len(word2)
        dp = [[0] * (len2 + 1) for i in range(len1 + 1)]
        for i in range(1, len1 + 1): dp[i][0] = i
        for j in range(1, len2 + 1): dp[0][j] = j
        for i in range(1, len1 + 1):
            for j in range(1, len2 + 1):
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, 
                    dp[i - 1][j - 1] if word1[i - 1] == word2[j - 1] else dp[i - 1][j - 1] + 1)
        return dp[-1][-1]
```

### 73. Set Matrix Zeroes

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        R, C, row, col = len(matrix), len(matrix[0]), set(), set()
        for r in range(R):
            for c in range(C):
                if matrix[r][c] == 0:
                    row.add(r)
                    col.add(c)
        for r in range(R):
            for c in range(C):
                if r in row or c in col:
                    matrix[r][c] = 0
```

### 74. Search a 2D Matrix

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        def search(nums, n):
            l, r = 0, len(nums) - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > n:
                    r = m - 1
                elif nums[m] < n:
                    l = m + 1
                else:
                    return True
            return False
        # check column if not exist, leave it row, row will return false
        # if find, leave it to row, if exist, it will become true
        l, r = 0, len(matrix) - 1
        while l <= r:
            m = l + (r - l) // 2
            if matrix[m][0] > target:
                r = m - 1
            else:
                l = m + 1
            
        if search(matrix[l - 1], target):
            return True
        return False
```

### 75. Sort Colors

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] > nums[j]:
                    nums[i], nums[j] = nums[j], nums[i]
```
Follow up: Could you come up with a one-pass algorithm using only constant extra space?

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i, l, r = 0, 0, len(nums) - 1
        while i <= r:
            if nums[i] == 0:
                nums[i], nums[l] = nums[l], nums[i]
                l += 1
                i += 1
            elif nums[i] == 2:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            else:
                i += 1
```

### 76. Minimum Window Substring

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        res, l, tCounter, window = "", 0, Counter(t), Counter()
        for r, c in enumerate(s):
            window[c] += 1
            while window >= tCounter:
                if res == "" or r - l + 1 < len(res):
                    res = s[l: r + 1]
                window[s[l]] -= 1
                l += 1
        return res
```

### 842. Split Array into Fibonacci Sequence

```python
class Solution:
    def splitIntoFibonacci(self, num: str) -> List[int]:
        size, self.result = len(num), []
        def dfs(start, path):
            if self.result:
                return
            if len(path) > 2 and path[-3] + path[-2] != path[-1]:
                return
            if start == size and len(path) > 2:
                self.result = path[::]
                return
            for i in range(start, size):
                if (num[start] == '0' and i > start) or (int(num[start : i + 1]) > (2 ** 31)):
                    break
                path.append(int(num[start : i + 1]))
                dfs(i + 1, path)
                path.pop()
        dfs(0, [])
        return self.result
```
### 996. Number of Squareful Arrays

```python
class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        def isPerfect(n):
            return pow(int(sqrt(n)), 2) == n
        self.res = 0
        def backtrack(nums, ans):
            if not nums:
                self.res += 1
            s = set()
            for i in range(len(nums)):
                if nums[i] in s: continue
                s.add(nums[i])
                if not ans:
                    ans.append(nums[i])
                    backtrack(nums[:i] + nums[i+1:], ans)
                    ans.pop()
                elif isPerfect(ans[-1] + nums[i]):
                        ans.append(nums[i])
                        backtrack(nums[:i] + nums[i+1:], ans)
                        ans.pop()
        backtrack(nums, [])
        return self.res
```
## 208. Implement Trie (Prefix Tree)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.endOfWord

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
```

### 131. Palindrome Partitioning

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def isPanlindrome(s):
            return s == ''.join(reversed(list(s)))

        res, ans, n = [], [], len(s)
        def backtrack(i):
            if i >= n:
                res.append(ans[::])
                return
            for j in range(i, n):
                if isPanlindrome(s[i: j + 1]):
                    ans.append(s[i: j + 1])
                    backtrack(j + 1)
                    ans.pop()
        backtrack(0)
        return res
```

### 132. Palindrome Partitioning II

```python
class Solution:
    def minCut(self, s: str) -> int:
        g, n = defaultdict(set), len(s)
        def helper(l, r):
            while l >= 0 and r < n and s[l] == s[r]:
                g[l].add(r)
                l -= 1
                r += 1
        for i in range(n):
            helper(i, i)
            helper(i, i + 1)
        
        @lru_cache(None)
        def dfs(i):
            if i >= n:
                return 0
            ans = n
            for j in range(i, n):
                if j in g[i]:
                    ans = min(ans, dfs(j + 1) + 1)
            return ans
        return dfs(0) - 1
```

### 165. Compare Version Numbers

```python
class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        v1, v2 = list(map(int, version1.split('.'))), list(map(int, version2.split('.')))  
        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):
            if rev1 == rev2:
                continue
            return -1 if rev1 < rev2 else 1 
        return 0
```

### 1278. Palindrome Partitioning III

```python
```

### 560. Subarray Sum Equals K

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        d, res, presum = {0: 1}, 0, 0
        for n in nums:
            presum += n
            prev_vals = presum - k
            if prev_vals in d:
                res += d[prev_vals]
            d[presum] = d.get(presum, 0) + 1
        return res
```

### 213. House Robber II

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def rob_a_line(nums):
            nums, prev = [0] + nums, 0
            for i in range(2, len(nums)):
                prev = max(prev, nums[i - 2])
                nums[i] += prev
            return max(nums[-2:])
        if len(nums) == 1:
            return nums[0]
        return max(rob_a_line(nums[1: ]), rob_a_line(nums[: -1]))
```

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n, nums1, nums2 =len(nums), [0] + nums[: -1], [0] + nums[1: ]
        if n == 1:
            return nums[0]
        for i in range(2, n):
            nums1[i] = max(nums1[i - 1], nums1[i - 2] + nums1[i])
            nums2[i] = max(nums2[i - 1], nums2[i - 2] + nums2[i])
        return max(nums1[-2: ] + nums2[-2: ]) 
```

### 540. Single Element in a Sorted Array

```python
```

### 978. Longest Turbulent Subarray

```python
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        n, res = len(arr), 1
        dp1, dp2 = [1] * n, [1] * n
        for i in range(0, n - 1):
            if i % 2:
                if arr[i] > arr[i + 1]:
                    dp1[i + 1] += dp1[i]
                elif arr[i] < arr[i + 1]:
                    dp2[i + 1] += dp2[i]
            else:
                if arr[i] < arr[i + 1]:
                    dp1[i + 1] += dp1[i]
                elif arr[i] > arr[i + 1]:
                    dp2[i + 1] += dp2[i]
            res = max(res, dp1[i + 1], dp2[i + 1])
        return res
```

### 537. Complex Number Multiplication

```python
class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        a1, a2 = map(int, num1[:-1].split('+'))
        b1, b2 = map(int, num2[:-1].split('+'))
        return '%d+%di' % (a1 * b1 - a2 * b2, a1 * b2 + a2 * b1)
```
## 648. Replace Words

### set

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        d = set(dictionary)
        def replace(word):
            for i in range(1, len(word)):
                if word[:i] in d:
                    return word[:i]
            return word
        return " ".join(map(replace, sentence.split()))
```

### Trie

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def replace(self, word: str) -> bool:
        cur = self.root
        for i, c in enumerate(word):
            if c not in cur.children:
                break
            cur = cur.children[c]
            if cur.endOfWord:
                return word[: i + 1]
        return word

class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for prefix in dictionary:
            trie.insert(prefix)
        return " ".join(map(trie.replace, sentence.split()))
```

### 662. Maximum Width of Binary Tree

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        q, res = deque([(root, 1)]), 0
        while q:
            left, right = q[0][1], q[-1][1]
            res = max(res, right - left + 1)
            for i in range(len(q)):
                node, index = q.popleft()
                if node.left: q.append((node.left, 2 * index))
                if node.right: q.append((node.right, 2 * index + 1))
        return res
```

### 1268. Search Suggestions System (Trie)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.words = []
        self.n = 0
        
class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children: 
                cur.children[c] = TrieNode()
            cur = cur.children[c] 
            if cur.n < 3:
                cur.words.append(word)
                cur.n += 1
        
    def find(self, prefix):
        cur = self.root
        for c in prefix:
            if c not in cur.children: 
                return ''
            cur = cur.children[c] 
        return cur.words
            
class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()
        trie = Trie()
        for word in products: 
            trie.insert(word)
        ans, cur = [], ''
        for c in searchWord:
            cur += c 
            ans.append(trie.find(cur))
        return ans    
```


### 1631. Path With Minimum Effort

```python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        R, C = len(heights), len(heights[0])
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        res, minHeap, visited = 0, [(0, 0, 0)], set([(0, 0)])
        while minHeap:
            k, r, c = heappop(minHeap)
            res = max(res, k)
            if (r, c) == (R - 1, C - 1):
                return res
            visited.add((r, c))
            for dr, dc in directions:
                row, col = dr + r, dc + c
                if 0 <= row < R and 0 <= col < C and (row, col) not in visited:
                    new_k = abs(heights[r][c] - heights[row][col])
                    heappush(minHeap, (new_k, row, col))
```

### 2731. Movement of Robots

```python
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        for i, n in enumerate(nums):
            if s[i] == 'R':
                nums[i] += d
            else:
                nums[i] -= d

        nums.sort()
        res = [nums[i] - nums[i - 1] for i in range(1, len(nums))]
        n, ans = len(res), 0
        for i in range(n):
            ans += (i + 1) * (n - i) * res[i]
        return ans % (10 ** 9 + 7)
```

### 剑指 Offer 38. 字符串的排列 (permunation)
输入一个字符串，打印出该字符串中字符的所有排列。

 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 

示例:

输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
 

限制：

1 <= s 的长度 <= 8

```python
class Solution:
    def permutation(self, s: str) -> List[str]:
        def backtrack(letters, ans, res):
            if not letters:
                res.append(''.join(ans[::]))
            s = set()
            for i in range(len(letters)):
                if letters[i] in s: continue
                s.add(letters[i])
                ans.append(letters[i])
                backtrack(letters[:i] + letters[i+1:], ans, res)
                ans.pop()
            return res
        return backtrack(s, [], [])
```
### 1072. Flip Columns For Maximum Number of Equal Rows

```python
class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = defaultdict(int)
        for row in matrix:
            d[tuple(row)] += 1
            d[tuple([1 - c for c in row])] += 1
        return max(d.values())
```

### 1248. Count Number of Nice Subarrays

```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        length, window = len(nums), []
        for i, n in enumerate(nums): # put all odd index to window
            if n % 2:
                window.append(i)
        if len(window) < k: # not meet conditions
            return 0
        window = [-1] + window + [length] # padding head and tail to make calc easier
        res = 0
        for i in range(1, len(window) - k):
            res += (window[i] - window[i - 1]) * (window[i + k] - window[i + k - 1]) # core combinations
        return res
```
### 149. Max Points on a Line

#### D & C

#### line: 28

The question asked to use matrix

```python
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def calcSlope(a, b): # avoid 0 of dx or dy
            dx = a[0] - b[0]
            dy = a[1] - b[1]
            divisor = gcd(dx, dy)
            return (dx / divisor, dy / divisor) # use tuple as key

        if len(points) <= 2:
            return len(points)
        res = 0
        for i in range(len(points)):
            slopes, dups = {}, 1 # [0, 0], [0, 0] or [0, 0], [1, 1], [2, 2]
            for j in range(i + 1, len(points)):
                if points[i] == points[j]:
                    dups += 1
                else:
                    slope = calcSlope(points[i], points[j])
                    if slope in slopes:
                        slopes[slope] += 1
                    else:
                        slopes[slope] = 1
            for slope in slopes:
                res = max(res, slopes[slope] + dups)
        return res
```

### 187. Repeated DNA Sequences

#### set

#### line: 7

The question asked to use matrix

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        seen, res = set(), set()
        for i in range(len(s) - 9):
            cur = s[i: i + 10]
            if cur in seen:
                res.add(cur)
            seen.add(cur)
        return list(res)
```

### 384. Shuffle an Array

#### Fisher Yates Algorithms

#### line: 7

The question asked to use matrix

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.original = nums[: ]

    def reset(self) -> List[int]:
        return self.original

    def shuffle(self) -> List[int]:
        res = self.original[: ]
        # Fisher Yates Algorithms
        lastIndex = len(res) - 1
        while lastIndex > 0:
            randomIndex = random.randint(0, lastIndex)
            res[lastIndex], res[randomIndex] = res[randomIndex], res[lastIndex]
            lastIndex -= 1
        return res


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()
```

### 380. Insert Delete GetRandom O(1)

#### Fisher Yates Algorithms

#### line: 7

The question asked to use matrix

```python
class RandomizedSet:

    def __init__(self):
        self.set = set()

    def insert(self, val: int) -> bool:
        if val in self.set:
            return False
        self.set.add(val)
        return True

    def remove(self, val: int) -> bool:
        if val in self.set:
            self.set.remove(val)
            return True
        return False


    def getRandom(self) -> int:
        lst = list(self.set)
        random.shuffle(lst)
        return lst[0]


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```

### 173. Binary Search Tree Iterator

#### stack

#### line: 10

use stack + dfs iterative solution

```python
class BSTIterator:

    def __init__(self, root: Optional[TreeNode]):
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def next(self) -> int:
        res = self.stack.pop()
        cur = res.right
        while cur:
            self.stack.append(cur)
            cur = cur.left
        return res.val

    def hasNext(self) -> bool:
        return self.stack != []

```

### 373. Find K Pairs with Smallest Sums

#### D & C

#### line: 10

Keep all possible pairs in the heap and choose k smallest pairs

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        hq, res = [], []
        for i in range(min(len(nums1), k)):
            heapq.heappush(hq, (nums1[i] + nums2[0], nums1[i], nums2[0], 0)) # idx for nums2
        while k > 0 and hq:
            _, n1, n2, idx = heapq.heappop(hq)
            res.append([n1, n2])
            if idx + 1 < len(nums2):
                heapq.heappush(hq, (n1+nums2[idx+1], n1, nums2[idx+1], idx+1))
            k -= 1
        return res
```

### 491. Increasing Subsequences

#### memo

#### line: 12

The question asked to use set + backTracking

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        def backTracking(start, cur):
            if len(cur) > 1:
                res.add(tuple(cur))
            last = cur[-1] if cur else float('-inf')
            for i in range(start, n):
                if nums[i] >= last:
                    cur.append(nums[i])
                    backTracking(i + 1, cur)
                    cur.pop()

        res, n = set(), len(nums)
        backTracking(0, [])
        return res
```

### 743. Network Delay Time

#### min heap

#### line: 14

Use min heap and graph of Dijkstra's algorithms

```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        edges = collections.defaultdict(list)
        for u, v, w in times:
            edges[u].append((v, w))

        minHeap, visit, t = [(0, k)], set(), 0
        while minHeap:
            w1, n1 = heapq.heappop(minHeap)
            if n1 in visit:
                continue
            visit.add(n1)
            t = max(t, w1)
            for n2, w2 in edges[n1]:
                if n2 not in visit:
                    heapq.heappush(minHeap, (w1 + w2, n2))
        return t if len(visit) == n else -1
```

### 787. Cheapest Flights Within K Stops

#### min heap

#### line: 11

Use min heap and graph of Dijkstra's algorithms

```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        prices = [float('inf')] * n
        prices[src] = 0
        for i in range(k + 1):
            temp = prices.copy()

            for s, d, p in flights:
                if prices[s] == float('inf'):
                    continue
                if prices[s] + p < temp[d]:
                    temp[d] = prices[s] + p
            prices = temp
        return -1 if prices[dst] == float('inf') else prices[dst]
```

### 827. Making A Large Island

#### dfs

#### line: 26

The question asked to use map and dfs

```python
class Solution:
    def largestIsland(self, grid: List[List[int]]) -> int:
        def dfs(i, j, color): # color all components
            grid[i][j], area, points = color, 1, [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
            for r, c in points:
                if 0 <= r < n and 0 <= c < n and grid[r][c] == 1:
                    area += dfs(r, c, color)
            return area

        n, color, water, island = len(grid), 2, set(), {} # put color, area in island map
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 0:
                    water.add((i,j))
                elif grid[i][j] == 1:
                    area = dfs(i, j, color)
                    island[color] = area
                    color += 1

        res = island[2] if len(island) > 0 else 0 # is no water, area is island[2], only 1 color
        for i, j in water:
            area, visit, points = 1, set(), [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]
            for r, c in points:
                if 0 <= r < n and 0 <= c < n:
                    color = grid[r][c]
                    if color not in visit and color in island:
                        area += island[color]
                        visit.add(color)
            res = max(res, area)

        return res
```

### 1387. Sort Integers by The Power Value

#### memo

#### line: 21

The question asked to use divide and conquer
return true.

```python
class Solution:
    def getKth(self, lo: int, hi: int, k: int) -> int:
        memo = {1: 1}
        def helper(n):
            if not n in memo:
                if n % 2:
                    memo[n] = helper(3 * n + 1) + 1
                else:
                    memo[n] = helper(n / 2) + 1
            return memo[n]
        values = [[helper(i), i] for i in range(lo, hi + 1)]
        return sorted(values)[k - 1][1]
```

### 936. Stamping The Sequence

#### greedy

#### line: 24

The greedy method is to stamp the last one first, then the second last, we used '_'
to control every step should be ok, the first stamp must be a full width of stamp, then we have '_'
all other steps should be ok. If not ok, return false.

```python
class Solution:
    def movesToStamp(self, stamp: str, target: str) -> List[int]:
        def canStamp(start):
            flag = False
            for i in range(s):
                if targetList[start + i] == '?':
                    continue
                flag = True
                if stamp[i] != targetList[start + i]:
                    return False
            return flag

        s, t, targetList = len(stamp), len(target), list(target)
        remain, res = t, []
        while remain:
            flag = False

            for i in range(t - s + 1):
                if canStamp(i):
                    flag = True
                    res.append(i)
                    for j in range(s):
                        if targetList[i + j] != '?':
                            targetList[i + j] = '?'
                            remain -= 1
            if not flag:
                return []
        return res[::-1]
```

### 684. Redundant Connection

#### greedy

#### line: 22

The find is to find parent, the union is to union child and parent

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        par = [i for i in range(len(edges) + 1)]
        rank = [1] * (len(edges) + 1)

        def find(n):
            p = par[n]
            while p != par[p]:
                par[p] = par[par[p]] # quick find, can delete this line
                p = par[p]
            return p

        def union(n1, n2):
            p1, p2 = find(n1), find(n2)
            if p1 == p2:
                return False
            if rank[p1] >= rank[p2]:
                par[p2] = p1
                rank[p1] += rank[p2]
            else:
                par[p1] = p2
                rank[p2] += rank[p1]
            return True

        for n1, n2 in edges:
            if not union(n1, n2):
                return [n1, n2]
```

### 326. Power of Three

#### math

#### line: 1

```python
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        return n > 0 and (3**19) % n == 0
```

### 231. Power of Two

#### greedy

#### line: 22

The find is to find parent, the union is to union child and parent

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and 2**round(log(n, 2)) == n
```

### 342. Power of Four

#### greedy

#### line: 22

The find is to find parent, the union is to union child and parent

```python
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and not (n & (n - 1)) and not (n & 0xaaaaaaaa)
```

### 638. Shopping Offers

#### dp: knapsack unbounded

#### line: 12

This is a knapsack problem

```python
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        memo = {}
        def helper(price, special, needs):
            if tuple(needs) in memo:
                return memo[tuple(needs)]
            minPrice = sum([needs[i] * price[i] for i in range(len(needs))])
            for offer in special:
                if all([offer[i] <= needs[i] for i in range(len(needs))]):
                    newNeeds = [needs[i] - offer[i] for i in range(len(needs))]
                    minPrice = min(minPrice, offer[-1] + helper(price, special, newNeeds))
            memo[tuple(needs)] = minPrice
            return minPrice
        return helper(price, special, needs)

```

### 806. Number of Lines To Write String

#### dp: knapsack unbounded

#### line: 9

This is a one loop

```python
class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        line, pixels, letters, d = 1, 0, "abcdefghijklmnopqrstuvwxyz", {}
        for i, letter in enumerate(letters):
            d[letter] = widths[i]
        for c in s:
            pixels += d[c]
            if pixels > 100:
                line += 1
                pixels = d[c]
        return [line, pixels]
```

######################################################################################################
graph
######################################################################################################

### 1971. Find if Path Exists in Graph

#### graph + bfs

#### line: 16

bfs is used with a queue and visit set, in python it's deque(), bfs can use iterative easily

```python
class Solution:
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        queue, visited = deque(), set()
        queue.append(source)
        visited.add(source)
        while queue:
            node = queue.popleft()
            if node == destination:
                return True
            for adjacent_node in graph[node]:
                if adjacent_node not in visited:
                    queue.append(adjacent_node)
                    visited.add(adjacent_node)
        return False
```

### 1791. Find Center of Star Graph

#### graph

#### line: 7

adjacency list

```python
class Solution:
    def findCenter(self, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
            for node in graph.keys():
                if len(graph[node]) > 1:
                    return node
```

### 997. Find the Town Judge

#### graph

#### line: 8

degree of graph

```python
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        count = [0] * (n + 1) # do not calc using 0 index
        for u, v in trust: #indegree and outdegree
            count[u] -= 1
            count[v] += 1
        for i in range(1, len(count)):
            if count[i] == n - 1:
                return i
        return -1
```

### 797. All Paths From Source to Target

#### graph + dfs

#### line: 8

dfs of graph

```python
class Solution:
    def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
        def dfs(start, path, res):
            if start == end:
                res.append(path)
            for adjacent_node in graph[start]:
                dfs(adjacent_node, path + [adjacent_node], res)

        end, res = len(graph) - 1, []
        dfs(0, [0], res)
        return res
```

### 1557. Minimum Number of Vertices to Reach All Nodes

#### graph + indegree

#### line: 7

```python
class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        res, count = [], [0] * n # count indegrees
        for u, v in edges:
            count[v] += 1
        for i in range(len(count)): # check indegree of 0
            if count[i] == 0:
                res.append(i)
        return res
```

### 934. Shortest Bridge

```python
class Solution:
    def shortestBridge(self, grid: List[List[int]]) -> int:
        N, direct, visit = len(grid), [[0, 1], [0, -1], [1, 0], [-1, 0]], set()

        def outOfBounds(r, c):
            return r < 0 or c < 0 or r == N or c == N

        def dfs(r, c):
            if outOfBounds(r, c) or not grid[r][c] or (r, c) in visit:
                return
            visit.add((r, c))
            for dr, dc in direct:
                dfs(r + dr, c + dc)

        def bfs():
            res, q = 0, deque(visit)
            while q:
                for i in range(len(q)):
                    r, c = q.popleft()
                    for dr, dc in direct:
                        row, col = r + dr, c + dc
                        if outOfBounds(row, col) or (row, col) in visit:
                            continue
                        if grid[row][col]:
                            return res
                        q.append((row, col))
                        visit.add((row, col))
                res += 1

        for r in range(N):
            for c in range(N):
                if grid[r][c]:
                    dfs(r, c)
                    return bfs()
```

### 802. Find Eventual Safe States

```python
class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n, safe = len(graph), {}

        def dfs(i):
            if i in safe:
                return safe[i]
            safe[i] = False
            for nei in graph[i]:
                if not dfs(nei):
                    return safe[i]
            safe[i] = True
            return safe[i]
        res = []
        for i in range(n):
            if dfs(i):
                res.append(i)
        return res
```

933. Number of Recent Calls

```python
class RecentCounter:

    def __init__(self):
        self.q = deque()

    def ping(self, t: int) -> int:
        self.q.append(t)
        while self.q[0] < t - 3000:
            self.q.popleft()
        return len(self.q)
```

950. Reveal Cards In Increasing Order

the idea is how to build an arr by using queue, starting from the end to the begining

```python
class Solution:
    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
        q = deque()
        deck.sort(reverse = True)
        for card in deck:
            if q:
                q.appendleft(q.pop())
            q.appendleft(card)
        return q
```

1823. Find the Winner of the Circular Game

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        res, q = 0, deque([i for i in range(1, n + 1)])
        while q:
            for i in range(1, k):
                q.append(q.popleft())
            res = q.popleft()
        return res
```

1352. Product of the Last K Numbers

```python
class ProductOfNumbers:

    def __init__(self):
        self.a = [1]

    def add(self, num: int) -> None:
        if not num:
            self.a = [1]
        else:
            self.a.append(self.a[-1] * num)

    def getProduct(self, k: int) -> int:
        if len(self.a) <= k:
            return 0
        return self.a[-1] // self.a[-k - 1]


# Your ProductOfNumbers object will be instantiated and called as such:
# obj = ProductOfNumbers()
# obj.add(num)
# param_2 = obj.getProduct(k)
```

#####################################

2 pointers

443. String Compression

```python
class Solution:
    def compress(self, chars: List[str]) -> int:
        walker, runner = 0, 0
        while runner < len(chars):
            chars[walker] = chars[runner]
            count = 1

            while runner + 1 < len(chars) and chars[runner] == chars[runner+1]:
                runner += 1
                count += 1

            if count > 1:
                for c in str(count):
                    chars[walker+1] = c
                    walker += 1
            runner += 1
            walker += 1
        return walker
```

969. Pancake Sorting

```python
class Solution:
    def pancakeSort(self, arr: List[int]) -> List[int]:
        res, r = [], len(arr)
        while r > 1:
            l = arr.index(max(arr[:r])) #find index of max value
            arr[: l + 1] = reversed(arr[: l + 1]) # reverse to the max value
            res.append(l + 1) #append size
            arr[: r]=reversed(arr[: r]) # reverse all
            res.append(r) # append size
            r -= 1
        return res
```

1382. Balance a Binary Search Tree

```python
class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        def inOrder(root, nodes):
            if root:
                inOrder(root.left, nodes)
                nodes.append(root)
                inOrder(root.right, nodes)
            return nodes
        def arrToBST(l, r, nodes):
            if l > r:
                return None
            m = (l + r) // 2
            root = nodes[m]
            root.left = arrToBST(l, m - 1, nodes)
            root.right = arrToBST(m + 1, r, nodes)
            return root
        nodes = inOrder(root, [])
        return arrToBST(0, len(nodes) - 1, nodes)
```

1561. Maximum Number of Coins You Can Get

```python
class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        res, m = 0, len(piles) // 3 # m is the number of groups
        piles.sort(reverse = True) # sort in reverse order
        for i in range(1, 2 * m, 2): # always choose the second large value, ignore third value
            res += piles[i]
        return res
```

### 861. Score After Flipping Matrix

```python
class Solution:
    def matrixScore(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0])
        for r in range(rows):
            if grid[r][0] == 0:
                for c in range(cols):
                    grid[r][c] ^= 1

        for c in range(cols):
            cnt = sum(grid[r][c] for r in range(rows))
            if cnt < rows - cnt:
                for r in range(rows):
                    grid[r][c] ^= 1

        return sum(int("".join(map(str, grid[i])), 2) for i in range(rows))
```

### 419. Battleships in a Board

similar to 200 in dfs
O(n) space

```python
class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        rows, cols, directions = len(board), len(board[0]), [[-1, 0], [1, 0], [0, 1], [0, -1]]
        def dfs(i, j):
            # board[i][j] == '.' # no use for this line
            for r, c in directions:
                dr = r + i
                dc = c + j
                if dr >= 0 and dc >= 0 and dr < rows and dc < cols and board[dr][dc] == 'X' and (dr, dc) not in visit:
                    visit.add((dr, dc))
                    dfs(dr, dc)

        res, visit = 0, set()
        for i in range(rows):
            for j in range(cols):
                if board[i][j] == 'X' and (i, j) not in visit:
                    dfs(i, j)
                    res += 1
        return res
```

O(1) space

```python
class Solution:
    def countBattleships(self, board: List[List[str]]) -> int:
        res, rows, cols = 0, len(board), len(board[0])
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == 'X' and (r == 0 or board[r-1][c] == '.') and (c == 0 or board[r][c-1] == '.'):
                    res += 1
        return res
```

dfs

1 200. Number of Islands

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(grid, r, c):
            grid[r][c] = '0'
            points = [[r - 1, c], [r + 1, c], [r, c + 1], [r, c - 1]]
            for row, col in points:
                if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == '1':
                    dfs(grid, row, col)

        count = 0
        ROWS, COLS = len(grid), len(grid[0])
        for i in range(ROWS):
            for j in range(COLS):
                if grid[i][j] == '1':
                    dfs(grid, i, j)
                    count += 1
        return count
```

### 386. Lexicographical Numbers

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        res = [str(i) for i in range(1, n + 1)]
        res.sort()
        return [int(s) for s in res]
```

```python
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        def dfs(x):
            """Pre-order traverse the tree."""
            if x <= n:
                ans.append(x)
                for i in range(10):
                    dfs(10 * x + i)

        ans = []
        for i in range(1, 10):
            dfs(i)
        return ans
```

### 993. Cousins in Binary Tree

this is much easier than dfs

```python
class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
        d = {}
        def dfs(node, parent, depth):
            if not node:
                return
            dfs(node.left, node, depth + 1)
            dfs(node.right, node, depth + 1)
            if node.val in (x, y):
                d[node.val] = (parent, depth)

        dfs(root, None, 0)
        res = x in d and y in d and d[x][1] == d[y][1] and d[x][0] != d[y][0]
        return res
```

##################################################################

### dp

#### 1d array: 70, 118, 119, 121, 338, 392, 509, 746, 1137

###### 118 == 119, 70 == 509 == 1137, 392: 2 pointers

### 70. Climbing Stairs

### line: 5

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        dp = [1]
        for i in range(1, rowIndex + 1):
            addZero = [0] + dp + [0]
            dp = [addZero[i - 1] + addZero[i] for i in range(1, len(addZero))]
        return dp
```

### 118. Pascal's Triangle

### line: 6

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        res = [[1]]
        for i in range(2, numRows + 1):
            addZero = [0] + res[-1] + [0]
            dp = [addZero[i - 1] + addZero[i] for i in range(1, len(addZero))]
            res.append(dp)
        return res
```

### 119. Pascal's Triangle II

### line: 5

```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        dp = [1]
        for i in range(1, rowIndex + 1):
            addZero = [0] + dp + [0]
            dp = [addZero[i - 1] + addZero[i] for i in range(1, len(addZero))]
        return dp
```

### 121. Best Time to Buy and Sell Stock

### line: 5

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        lowest, profit = prices[0], 0
        for price in prices:
            lowest = min(lowest, price)
            profit = max(profit, price - lowest)
        return profit
```

### 338. Counting Bits

### line: 7

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, len(dp)):
            if i % 2 == 1:
                dp[i] = dp[i // 2] + 1
            else:
                dp[i] = dp[i // 2]
        return dp
```

### 392. Is Subsequence

### 2 pointers

### line: 8

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        while i < len(s) and j < len(t):
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1
        return i == len(s)
```

### 509. Fibonacci Number

### line: 6

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        first, second = 0, 1
        for i in range(2, n + 1):
            second, first = second + first, second
        return second
```

### 746. Min Cost Climbing Stairs

### line: 3

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        for i in range(2, len(cost)):
            cost[i] += min(cost[i - 2], cost[i - 1])
        return min(cost[-2:])

```

### 1137. N-th Tribonacci Number

### line: 8

```python
class Solution:
    def tribonacci(self, n: int) -> int:
        if n < 2:
            return n
        elif n == 2:
            return 1
        first, second, third = 0, 1, 1
        for i in range(3, n + 1):
            third, second, first = third + second + first, third, second
        return third
```

### 1646. Get Maximum in Generated Array

### line: 9

```python
class Solution:
    def getMaximumGenerated(self, n: int) -> int:
        if n==0:
            return 0
        dp = [0, 1]
        for i in range(2, n+1):
            if i % 2==0:
                dp.append(dp[i // 2])
            else:
                dp.append(dp[i // 2] + dp[i // 2 + 1])
        return max(dp)
```

### 1025. Divisor Game

```python
class Solution:
    def divisorGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            for j in range(1, i // 2 + 1):
                if i % j == 0 and not dp[i - j]:
                    dp[i] = True # if i need to win, next step to Bob is dp[i - j] must be false
                    break # this is optimal
        return dp[-1]
```

### 198. House Robber

#### line: 4

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        nums = [0] + nums # use nums as dp
        for i in range(2, len(nums)):
            nums[i] = max(nums[i - 1], nums[i - 2] + nums[i])
        return nums[-1]
```

### 213. House Robber II

#### line: 5

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        nums1, nums2 = [0] + nums[: -1], [0] + nums[1: ]
        for i in range(2, len(nums1)):
            nums1[i] = max(nums1[i - 1], nums1[i - 2] + nums1[i])
            nums2[i] = max(nums2[i - 1], nums2[i - 2] + nums2[i])
        return max(nums1[-1], nums2[-1], nums[0])
```

### 740. Delete and Earn

#### line: 6

```python
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        dp = [0] * (max(nums) + 1) # dp index is houses 0, 1, 2, ...
        for n in nums: # the problem is now house robbers
            dp[n] += n
        for i in range(2, len(dp)):
            dp[i] = max(dp[i - 1], dp[i] + dp[i - 2])
        return dp[-1]
```

### 55. Jump Game

#### line: 7

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        res = 0
        for i in range(len(nums)):
            res = max(res, i + nums[i])
            if (res >= len(nums) - 1):
                return True
            elif res <= i:
                return False
```

### 45. Jump Game II

### dp

```python
# method 1: dp
        dp = [0] * len(nums) # last number of dp is the value
        for i in range(1, len(nums)):
            min_value = float('inf')
            for j in range(i):
                if i - j <= nums[j]:
                    min_value = min(min_value, dp[j] + 1)
            dp[i] = min_value
        return dp[-1] # time too long
```

### greedy

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        res, l, r = 0, 0, 0 # window of indexes
        while r < len(nums) - 1:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            l = r + 1
            r = farthest
            res += 1
        return res
```

### 1014. Best Sightseeing Pair

```python
class Solution:
    def maxScoreSightseeingPair(self, values: List[int]) -> int:
        res, cur = 0, 0
        for i in range(1, len(values)):
            cur = max(cur, values[i - 1] + i - 1)
            res = max(res, cur + values[i] - i)
        return res
```

### 53. Maximum Subarray

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        dp = [float('-inf')] * (len(nums) + 1)
        for i in range(1, len(dp)):
            dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1])
        return max(dp)
```

### 918. Maximum Sum Circular Subarray

```python
class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        def maxSubarraySum(nums):
            dp = [float('-inf')] * (len(nums) + 1)
            for i in range(1, len(dp)):
                dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1])
            return max(dp)

        if len(nums) == 1:
            return nums[0]
        drop = maxSubarraySum(nums[1:])
        pick = sum(nums) - min(0, -maxSubarraySum([-number for number in nums[1:]]))
        return max(drop, pick)
```

### 729. My Calendar I

```python
class TreeNode():
    def __init__(self, s, e):
        self.s = s
        self.e = e
        self.left = None
        self.right = None

class MyCalendar:

    def __init__(self):
        self.root = None

    def book(self, start: int, end: int) -> bool:
        if not self.root:
            self.root = TreeNode(start, end)
            return True
        else:
            return self.insert(start, end, self.root)

    def insert(self, s, e, node):
        if s >= node.e:
            if node.right:
                return self.insert(s, e, node.right)
            else:
                node.right = TreeNode(s, e)
                return True
        elif e <= node.s:
            if node.left:
                return self.insert(s, e, node.left)
            else:
                node.left = TreeNode(s, e)
                return True
        else:
            return False


# Your MyCalendar object will be instantiated and called as such:
# obj = MyCalendar()
# param_1 = obj.book(start,end)
```

### 731. My Calendar II

```python
class MyCalendarTwo:

    def __init__(self):
        self.lst = []

    def book(self, start: int, end: int) -> bool:
        self.lst.append((start, +1)) # one booking added at startingtime = start
        self.lst.append((end, -1)) # booking ends at timestamp = end

        self.lst.sort()
        overlaps = 0
        for book in self.lst:
            overlaps += book[1]
            if overlaps > 2:
                self.lst.remove((start, +1)) # remove the booking that is causing problems (triple overlap)
                self.lst.remove((end, -1))
                return False
        return True


# Your MyCalendarTwo object will be instantiated and called as such:
# obj = MyCalendarTwo()
# param_1 = obj.book(start,end)
```

############################################################################

## dp

### Minimum (Maximum) Path to Reach a Target

### 64. Minimum Path Sum

how to reach the target, check the last step, then find the function

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        rows, cols, first = len(grid), len(grid[0]), grid[0][0]
        # state
        dp = [[first] * cols for i in range(rows)]
        # init rows
        for j in range(1, cols):
            dp[0][j] = dp[0][j - 1] + grid[0][j]
        # init cols
        for i in range(1, rows):
            dp[i][0] = dp[i - 1][0] + grid[i][0]
        # top-down
        for i in range(1, rows):
            for j in range(1, cols):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        return dp[-1][-1]
```

### 120. Triangle

how to reach the target, check the last step, then find the function

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        # state
        dp = triangle[-1]
        # bottom-up
        for row in triangle[::-1][1:]:
            for i, v in enumerate(row):
                dp[i] = v + min(dp[i], dp[i + 1])
        return dp[0]
```

### 174. Dungeon Game

```python
class Solution:
    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:
        rows, cols = len(dungeon), len(dungeon[0])
        dp = [[0] * cols for i in range(rows)]

        # state: need at least 1 point to survive
        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])

        # rows
        for i in range(rows - 2, -1, -1):
            dp[i][-1] = max(1, dp[i + 1][-1] - dungeon[i][-1])
        # cols
        for j in range(cols - 2, -1, -1):
            dp[-1][j] = max(1, dp[-1][j + 1] - dungeon[-1][j])

        # bottom-up
        for i in range(rows-2, -1, -1):
            for j in range(cols - 2, -1, -1):
                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])
        return dp[0][0]
```

### 221. Maximal Square

same as 1277

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        res, rows, cols = 0, len(matrix) + 1, len(matrix[0]) + 1
        # state
        dp = [[0] * cols  for i in range(rows)]
        # top-down
        for i in range(1, rows): # rows
            for j in range(1, cols): # cols
                if matrix[i-1][j-1] == '1':
                    dp[i][j] = min([dp[i-1][j-1], dp[i-1][j], dp[i][j-1]]) + 1
                    res = max(res, dp[i][j])
        return res ** 2
```

### 1277. Count Square Submatrices with All Ones

same as 221

```python
class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        res, rows, cols = 0, len(matrix) + 1, len(matrix[0]) + 1
        dp = [[0] * cols  for i in range(rows)]
        for i in range(1, rows): # rows
            for j in range(1, cols): # cols
                if matrix[i - 1][j - 1] == 1:
                    dp[i][j] = min([dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]]) + 1
        res = sum([sum(item) for item in dp])
        return res
```

### 931. Minimum Falling Path Sum

same as 1289

```python
class Solution:
    def minFallingPathSum(self, matrix: List[List[int]]) -> int:
        rows, cols = len(matrix), len(matrix[0]) + 2
        dp = [[float('inf')] * cols for i in range(rows)]
        for j in range(1, cols - 1):
            dp[0][j] = matrix[0][j - 1]
        for i in range(1, rows):
            for j in range(1, cols - 1):
                dp[i][j] = min(dp[i - 1][j - 1: j + 2]) + matrix[i][j - 1]
        return min(dp[-1])
```

### 1289. Minimum Falling Path Sum II

same as 931

```python
class Solution:
    def minFallingPathSum(self, grid: List[List[int]]) -> int:
        rows, cols = len(grid), len(grid[0]) + 2
        dp = [[float('inf')] * cols for i in range(rows)]
        for j in range(1, cols - 1):
            dp[0][j] = grid[0][j - 1]
        for i in range(1, rows):
            for j in range(1, cols - 1):
                dp[i][j] = min(dp[i - 1][: j] + dp[i - 1][j + 1:]) + grid[i][j - 1]
        return min(dp[-1])
```

### 576. Out of Boundary Paths

```python
class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        memo = {}
        def dfs(i, j, maxMove):
            if (i, j, maxMove) in memo:
                return memo[(i, j, maxMove)]
            if maxMove < 0:
                return 0
            if i < 0 or i >= m or j < 0 or j >= n:
                return 1
            res, directions = 0, [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]
            for r, c in directions:
                ans = dfs(r, c, maxMove - 1)
                memo[(r, c, maxMove - 1)] = ans
                res += ans
            return res

        return dfs(startRow, startColumn, maxMove) % (10 ** 9 + 7)
```

### 688. Knight Probability in Chessboard

```python
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        @functools.lru_cache(None)
        def dfs(r, c, k):
            if r < 0 or r >= n or c < 0 or c >= n:
                return 0
            elif k == 0:
                return 1
            else:
                res, directions = 0, [(r + 2, c + 1), (r + 1, c + 2), (r - 1, c + 2), (r - 2, c + 1),
                             (r - 2, c - 1), (r - 1, c - 2), (r + 1, c - 2), (r + 2, c - 1)]
                for row, col in directions:
                    res += dfs(row, col, k - 1) / 8
                return res

        return dfs(row, column, k)
```

### 669. Trim a Binary Search Tree

### dfs

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root:
            return None
        elif root.val < low:
            return self.trimBST(root.right, low, high)
        elif root.val > high:
            return self.trimBST(root.left, low, high)
        root.left = self.trimBST(root.left, low, high)
        root.right = self.trimBST(root.right, low, high)
        return root
```

### 1254. Number of Closed Islands

```python
class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        def dfs(i, j):
            if grid[i][j] == 1:
                return True
            elif i <= 0 or i >= row - 1 or j <= 0 or j >= col - 1:
                return False
            grid[i][j] = 1
            up = dfs(i - 1, j)
            down = dfs(i + 1, j)
            left = dfs(i, j - 1)
            right = dfs(i, j + 1)
            return up and down and left and right

        res, row, col = 0, len(grid),len(grid[0])
        for i in range(1, row - 1):
            for j in range(1, col - 1):
                if not grid[i][j] and dfs(i, j):
                    res += 1
        return res
```

### 508. Most Frequent Subtree Sum

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node):
            if node is None:
                return 0
            res = node.val
            if node.left:
                res += dfs(node.left)
            if node.right:
                res += dfs(node.right)
            d[res] += 1
            return res

        d = defaultdict(int)
        dfs(root)
        max_frequency = max(d.values())
        return [key for key, val in d.items() if val == max_frequency]
```

### bfs template

https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/635351/BFS-With-MaxValue-or-Template-of-Similar-Problems-Python

### 1448. Count Good Nodes in Binary Tree

```python
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        res, q = 0, deque([(root,-inf)])
        while q:
            node, maxval = q.popleft()
            if node.val >= maxval:
                res += 1
            if node.left:
                q.append((node.left, max(maxval, node.val)))
            if node.right:
                q.append((node.right, max(maxval, node.val)))
        return res
```

### 559. Maximum Depth of N-ary Tree

```python
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        res, q = -(math.inf), deque([(root, 1)])
        while q:
            node, depth = q.popleft()
            if not node.children:
                res = max(res, depth)
            for i in node.children:
                q.append((i, depth + 1))
        return res
```

### 112. Path Sum

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        q = deque([(root,0)])
        while q:
            node, value = q.popleft()
            if not node.left and not node.right:
                if targetSum == value + node.val:
                    return True
            if node.left:
                q.append((node.left,value + node.val))
            if node.right:
                q.append((node.right,value + node.val))
        return False
```

### 100. Same Tree

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        q = deque([p, q])
        while q:
            node1, node2= q.popleft(), q.popleft()
            if not node1 and not node2:
                continue
            if not node1 or not node2 or node1.val != node2.val:
                return False
            q.append(node1.left)
            q.append(node2.left)
            q.append(node1.right)
            q.append(node2.right)
        return True
```

### 101. Symmetric Tree

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        q = deque([root, root])
        while q:
            t1, t2 = q.popleft(), q.popleft()
            if not t1 and not t2:
                continue
            if not t1 or not t2 or t1.val != t2.val:
                return False
            q.append(t1.right)
            q.append(t2.left)
            q.append(t1.left)
            q.append(t2.right)
        return True
```

### 102. Binary Tree Level Order Traversal

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        queue, res = deque([root]), []

        while queue:
            level = []
            for i in range(len(queue)): # level count
                node = queue.popleft()
                level.append(node.val)
                if node.left:  queue.append(node.left)
                if node.right: queue.append(node.right)
            res.append(level)
        return res
```

### 865. Smallest Subtree with all the Deepest Nodes

```python
class Solution:
    def findDepth(self, node):
        if not node:
            return 0
        return 1 + max(self.findDepth(node.left), self.findDepth(node.right))

    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
        if self.findDepth(root.left) == self.findDepth(root.right):
            return root
        elif self.findDepth(root.left) > self.findDepth(root.right):
            return self.subtreeWithAllDeepest(root.left)
        else:
            return self.subtreeWithAllDeepest(root.right)
```

### 1123. Lowest Common Ancestor of Deepest Leaves

```python
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def findDepth(node):
            if not node:
                return 0
            return 1 + max(findDepth(node.left), findDepth(node.right))

        if findDepth(root.left) == findDepth(root.right):
            return root
        elif findDepth(root.left) > findDepth(root.right):
            return self.lcaDeepestLeaves(root.left)
        else:
            return self.lcaDeepestLeaves(root.right)
```

## Union Find

### 128. Longest Consecutive Sequence

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        res, s = 0, set(nums)
        while s:
            n = s.pop()
            p, q = n + 1, n - 1
            ans = 1
            while p in s:
                ans += 1
                s.remove(p)
                p += 1
            while q in s:
                ans += 1
                s.remove(q)
                q -= 1
            res = max(res, ans)
        return res
```

### 721. Accounts Merge

```python
class UF:
    def __init__(self, N):
        self.parents = list(range(N))

    def find(self, x):
        if self.parents[x] != x:
            return self.find(self.parents[x])
        return x

    def union(self, child, parent):
        self.parents[self.find(child)] = self.find(parent)

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        uf, ownership = UF(len(accounts)), {}
        for i, (_, *emails) in enumerate(accounts):
            for email in emails:
                if email in ownership:
                    uf.union(i, ownership[email])
                ownership[email] = i

        ans = collections.defaultdict(list)
        for email, owner in ownership.items():
            ans[uf.find(owner)].append(email)
        return [[accounts[i][0]] + sorted(emails) for i, emails in ans.items()]
```

### 684. Redundant Connection

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        par = [i for i in range(len(edges) + 1)]

        def find(n):
            if par[n] != n:
                return find(par[n])
            return n

        def union(n1, n2):
            par[find(n2)] = find(n1)

        for n1, n2 in edges:
            p1, p2 = find(n1), find(n2)
            if p1 != p2:
                union(n1, n2)
            else:
                return [n1, n2]
```

## 1 stone game

### 877. Stone Game

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        cache = {}
        def dfs(l, r):
            if l > r:
                return 0
            if (l, r) in cache:
                return cache[(l, r)]
            alice = True if (r - l) % 2 else False
            left = piles[l] if alice else 0
            right = piles[r] if alice else 0
            cache[(l, r)] = max(dfs((l + 1), r) + left, dfs(l, (r - 1)) + right)
            return cache[(l, r)]
        return dfs(0, len(piles) - 1) > (sum(piles)) // 2
```

### 1140. Stone Game II

```python
class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        N = len(piles)
        @lru_cache(None)
        def miniMax(idx, M):
            if idx == N:
                return 0
            res = float('-inf')
            for X in range(1, 2 * M + 1):
                stones = sum(piles[idx: idx + X])
                score = stones - miniMax(min(N, idx + X), max(M, X))
                res = max(res, score)
            return res
        return (sum(piles) + miniMax(0, 1)) // 2
```

### 1406. Stone Game III

```python
class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        N, M = len(stoneValue), 3
        @lru_cache(None)
        def miniMax(idx):
            if idx == N:
                return 0
            res, stones = float('-inf'), 0
            for X in range(idx, min(idx + 3, len(stoneValue))):
                stones += stoneValue[X]
                score = stones - miniMax(X + 1)
                res = max(res, score)
            return res
        res = miniMax(0)
        return 'Alice' if res > 0 else 'Bob' if res < 0 else'Tie'
```

### 1510. Stone Game IV

```python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        @lru_cache(None)
        def dfs(n):
            if not n:
                return False
            for i in range(1, int(sqrt(n)) + 1):
                if not dfs(n - i * i):
                    return True
            return False
        return dfs(n)
```

### 1686. Stone Game VI

```python
class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        res, alice, bob = [], 0, 0
        for i in range(len(aliceValues)):
            res.append((aliceValues[i] + bobValues[i], aliceValues[i], bobValues[i]))
        res.sort(reverse = True)

        for i in range(len(res)):
            if i % 2 == 0:
                alice += res[i][1]
            else:
                bob += res[i][2]
        return 1 if alice > bob else -1 if alice < bob else 0
```

## 2 jump game### 2

1480. Running Sum of 1d Array

```python
class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
        for i in range(1, len(nums)):
            nums[i] += nums[i - 1]
        return nums
```

### 3

724. Find Pivot Index

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        left, right = nums.copy(), nums.copy()
        right.reverse()
        for i in range(1, len(nums)):
            left[i] += left[i - 1]
            right[i] += right[i - 1]
        right.reverse()
        for i in range(len(nums)):
            if left[i] == right[i]:
                return i
        return -1
```

### 4

205. Isomorphic Strings

```python
class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        def checkIsomorphic(a, b, d):
            for i in range(len(a)):
                if a[i] not in d:
                    d[a[i]] = b[i]
                else:
                    if d[a[i]] != b[i]:
                        return False
            return True
        return checkIsomorphic(s, t, {}) and checkIsomorphic(t, s, {})
```

### 5

392. Is Subsequence

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        i, j = 0, 0
        while (i < len(s) and j < len(t)):
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1
        return i == len(s)
```

### 6

206. Reverse Linked List

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head
        while curr:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```

### 7

876. Middle of the Linked List

```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

### 8

142. Linked List Cycle II

```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        s = set()
        while head:
            if head in s:
                return head
            s.add(head)
            head = head.next
        return None
```

```python
# https://leetcode.com/problems/linked-list-cycle-ii/discuss/44822/Java-two-pointer-solution.
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                slow = head
                while slow:
                    if slow == fast:
                        return slow
                    slow = slow.next
                    fast = fast.next
        return None
```

### 9

121. Best Time to Buy and Sell Stock

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        lowest = prices[0]
        profit = 0
        for i in range(1, len(prices)):
            lowest = min(lowest, prices[i])
            profit = max(profit, prices[i] - lowest)
        return profit
```

### 11

300. Longest Increasing Subsequence

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for n in nums:
            if not res or n > res[-1]:
                res.append(n)
            else:
                l, r = 0, len(res) - 1
                while l < r:
                    m = (l + r) // 2
                    if res[m] < n:
                        l += 1
                    else:
                        r = m
                res[l] = n
        return len(res)
```

### 12

354. Russian Doll Envelopes

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key = lambda x: (x[0], -x[1]))
        nums = []
        for item in envelopes:
            nums.append(item[1])

        # LIS
        res = []
        for n in nums:
            if not res or n > res[-1]:
                res.append(n)
            else:
                l, r = 0, len(res) - 1
                while l < r:
                    m = (l + r) // 2
                    if res[m] < n:
                        l += 1
                    else:
                        r = m
                res[l] = n
        return len(res)
```

### 13

589. N-ary Tree Preorder Traversal

```python
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if not root:
            return []
        res = [root.val]
        if root.children:
            for child in root.children:
                res += self.preorder(child)
        return res
```

### 14

102. Binary Tree Level Order Traversal

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue, result = deque([root]), []

        while queue:
            level = []
            for i in range(len(queue)):
                node = queue.popleft()
                level.append(node.val)
                if node.left:  queue.append(node.left)
                if node.right: queue.append(node.right)
            result.append(level)
        return result
```

### 15

509. Fibonacci Number

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2:
            return n
        first, second = 0, 1
        for i in range(2, n + 1):
            first, second = second, first + second
        return second
```

### 19

1094. Car Pooling
      method 1

```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips.sort(key = lambda x : x[1])
        minHeap = [] # python used min heap and used index 0 for heap calculation
        curr = 0
        for t in trips:
            num, start, end = t
            while minHeap and minHeap[0][0] <= start:
                curr -= minHeap[0][1]
                heapq.heappop(minHeap)
            curr += num
            if curr > capacity:
                return False
            heapq.heappush(minHeap, [end, num])
        return True
```

method 2

```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        change = [0 for i in range(1001)]
        for t in trips:
            num, start, end = t
            change[start] += num
            change[end] -= num
        curr = 0
        for i in range(1001):
            curr += change[i]
            if curr > capacity:
                return False
        return True
```

### 20

1638. Count Substrings That Differ by One Character

```python
class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        # count all numbers
        res = 0
        # brute force check all conditions
        for i in range(len(s)):
            for j in range(len(t)):
                x, y = i, j
                # check when to count res and when to stop
                count = 0
                while x < len(s) and y < len(t):
                    if s[x] != t[y]:
                        count += 1
                    if count == 1:
                        res += 1
                    if count == 2:
                        break
                    x += 1
                    y += 1
        return res
```

### 22

299. Bulls and Cows

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        bucket = [0 for i in range(10)]
        for s, g in zip(secret, guess):
            if s == g:
                bulls += 1
            else:
                bucket[int(s)] += 1
                bucket[int(g)] -= 1
        return f'{bulls}A{len(secret) - bulls - sum(x for x in bucket if x > 0)}B'
```

### 23

475. Heaters

```python
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        def closest(heaters, house):
            l, r = 0, len(heaters) - 1
            min_dist = float('inf')
            while l <= r:
                m = (l + r) // 2
                min_dist = min(min_dist, abs(heaters[m] - house))
                if heaters[m] < house:
                    l = m + 1
                else:
                    r = m - 1
            return min_dist

        radius = 0
        heaters.sort()
        for house in houses:
            radius = max(radius, closest(heaters, house))
        return radius
```

### 24

403. Frog Jump

```python
class Solution:
    def canCross(self, stones: List[int]) -> bool:
        n = len(stones)
        stoneSet = set(stones)
        visited = set()
        def goFurther(value, units):
            if (value + units not in stoneSet) or ((value,units) in visited):
                return False
            if value + units == stones[n-1]:
                return True
            visited.add((value,units))
            return goFurther(value + units,units) or goFurther(value + units,units - 1) or goFurther(value + units,units + 1)
        return goFurther(stones[0], 1)
```

### 25

658. Find K Closest Elements

```python
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        n = len(arr)
        start = 0
        end = n - k
        while start < end:
            mid = (start + end) // 2
            if x - arr[mid] > arr[mid + k] - x:  # move right
                start = mid + 1
            else:
                end = mid
        return arr[start: start + k]
```

### 26 382. Linked List Random Node

https://leetcode.com/problems/linked-list-random-node/discuss/1672358/C%2B%2BPythonJava-Reservoir-sampling-oror-Prove-step-by-step-oror-Image

```python
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.nodes = []
        while head:
            self.nodes.append(head.val)
            head = head.next
    def getRandom(self) -> int:
        return random.choice(self.nodes)
```

### 27 817. Linked List Components

```python
class Solution:
    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
        s = set(nums)
        connected = False
        count = 0
        while head:
            if head.val in s and not connected:
                count += 1
                connected = True
            elif not head.val in s and connected:
                connected = False
            head = head.next
        return count
```

### 29 925. Long Pressed Name

```python
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        def getFrequencyArray(name):
            arr = []
            i = 0
            count = 1
            while i + 1 < len(name):
                if name[i] == name[i + 1]:
                    count += 1
                else:
                    arr.append([name[i], count])
                    count = 1
                i += 1
            if arr and name[-1] == arr[-1][0]:
                arr[-1][1] += 1
            else:
                arr.append([name[-1], 1])
            return arr

        nameArr = getFrequencyArray(name)
        typedArr = getFrequencyArray(typed)
        if (len(nameArr) != len(typedArr)):
            return False
        for i in range(len(nameArr)):
            if nameArr[i][0] != typedArr[i][0] or nameArr[i][1] > typedArr[i][1]:
                return False
        return True
```

### 30 859. Buddy Strings

```python
class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        # if lengths are different, then must be false
        if len(s) != len(goal):
            return False
        # If s and goal are same, then A must have duplicate character
        if s == goal:
            seen = set()
            for a in s:
                if a in seen:
                    return True
                seen.add(a)
            return False

        pair = []
        # when s and goal are not same
        for a, b in zip(s, goal):
            if a != b:
                pair.append((a, b))
            if len(pair) > 2:
                return False

        return len(pair) == 2 and pair[0] == pair[1][::-1]
```

dfs

1 200. Number of Islands

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def dfs(grid, r, c):
            grid[r][c] = '0'
            points = [[r - 1, c], [r + 1, c], [r, c + 1], [r, c - 1]]
            for row, col in points:
                if row >= 0 and col >= 0 and row < len(grid) and col < len(grid[0]) and grid[row][col] == '1':
                    dfs(grid, row, col)

        count = 0
        ROWS, COLS = len(grid), len(grid[0])
        for i in range(ROWS):
            for j in range(COLS):
                if grid[i][j] == '1':
                    dfs(grid, i, j)
                    count += 1
        return count
```

2 94. Binary Tree Inorder Traversal

```python
# recursive
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node, arr):
            if not node:
                return node
            dfs(node.left, arr)
            arr.append(node.val)
            dfs(node.right, arr)
            return arr
        return dfs(root, [])
# iterative
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack = [], []
        while True:
            while root:
                stack.append(root)
                root = root.left
            if not stack:
                return res
            node = stack.pop()
            res.append(node.val)
            root = node.right
```

3 144. Binary Tree Preorder Traversal

```python
# recursive
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node, arr):
            if not node:
                return node
            arr.append(node.val)
            dfs(node.left, arr)
            dfs(node.right, arr)
            return arr
        return dfs(root, [])
# iterative
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res, stack = [], [root]
        while stack:
            node = stack.pop()
            if node:
                res.append(node.val)
                stack.extend([node.right, node.left])
        return res
```

4 145. Binary Tree Postorder Traversal

```python
# recursive
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node, arr):
            if not node:
                return node
            dfs(node.left, arr)
            dfs(node.right, arr)
            arr.append(node.val)
            return arr
        return dfs(root, [])
# iterative
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        # modified preorder
        res, stack = [], [root]
        while stack:
            node = stack.pop()
            if node:
                res.append(node.val)
                stack.extend([node.left, node.right])
        return res[::-1]
```

### 11

300. Longest Increasing Subsequence

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        res = []
        for n in nums:
            if not res or n > res[-1]:
                res.append(n)
            else:
                l, r = 0, len(res) - 1
                while l < r:
                    m = (l + r) // 2
                    if res[m] < n:
                        l += 1
                    else:
                        r = m
                res[l] = n
        return len(res)
```

### 12

354. Russian Doll Envelopes

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        envelopes.sort(key = lambda x: (x[0], -x[1]))
        nums = []
        for item in envelopes:
            nums.append(item[1])

        # LIS
        res = []
        for n in nums:
            if not res or n > res[-1]:
                res.append(n)
            else:
                l, r = 0, len(res) - 1
                while l < r:
                    m = (l + r) // 2
                    if res[m] < n:
                        l += 1
                    else:
                        r = m
                res[l] = n
        return len(res)
```

### 19

1094. Car Pooling
      method 1

```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        trips.sort(key = lambda x : x[1])
        minHeap = [] # python used min heap and used index 0 for heap calculation
        curr = 0
        for t in trips:
            num, start, end = t
            while minHeap and minHeap[0][0] <= start:
                curr -= minHeap[0][1]
                heapq.heappop(minHeap)
            curr += num
            if curr > capacity:
                return False
            heapq.heappush(minHeap, [end, num])
        return True
```

method 2

```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        change = [0 for i in range(1001)]
        for t in trips:
            num, start, end = t
            change[start] += num
            change[end] -= num
        curr = 0
        for i in range(1001):
            curr += change[i]
            if curr > capacity:
                return False
        return True
```

### 20

1638. Count Substrings That Differ by One Character

```python
class Solution:
    def countSubstrings(self, s: str, t: str) -> int:
        # count all numbers
        res = 0
        # brute force check all conditions
        for i in range(len(s)):
            for j in range(len(t)):
                x, y = i, j
                # check when to count res and when to stop
                count = 0
                while x < len(s) and y < len(t):
                    if s[x] != t[y]:
                        count += 1
                    if count == 1:
                        res += 1
                    if count == 2:
                        break
                    x += 1
                    y += 1
        return res
```

### 21

299. Bulls and Cows

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        bulls = 0
        bucket = [0 for i in range(10)]
        for s, g in zip(secret, guess):
            if s == g:
                bulls += 1
            else:
                bucket[int(s)] += 1
                bucket[int(g)] -= 1
        return f'{bulls}A{len(secret) - bulls - sum(x for x in bucket if x > 0)}B'
```

### 23

475. Heaters

```python
class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        def closest(heaters, house):
            l, r = 0, len(heaters) - 1
            min_dist = float('inf')
            while l <= r:
                m = (l + r) // 2
                min_dist = min(min_dist, abs(heaters[m] - house))
                if heaters[m] < house:
                    l = m + 1
                else:
                    r = m - 1
            return min_dist

        radius = 0
        heaters.sort()
        for house in houses:
            radius = max(radius, closest(heaters, house))
        return radius
```

### 24

403. Frog Jump

```python
class Solution:
    def canCross(self, stones: List[int]) -> bool:
        n = len(stones)
        stoneSet = set(stones)
        visited = set()
        def goFurther(value, units):
            if (value + units not in stoneSet) or ((value,units) in visited):
                return False
            if value + units == stones[n-1]:
                return True
            visited.add((value,units))
            return goFurther(value + units,units) or goFurther(value + units,units - 1) or goFurther(value + units,units + 1)
        return goFurther(stones[0], 1)
```

### 25

658. Find K Closest Elements

```python
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        n = len(arr)
        start = 0
        end = n - k
        while start < end:
            mid = (start + end) // 2
            if x - arr[mid] > arr[mid + k] - x:  # move right
                start = mid + 1
            else:
                end = mid
        return arr[start: start + k]
```

### 26 382. Linked List Random Node

https://leetcode.com/problems/linked-list-random-node/discuss/1672358/C%2B%2BPythonJava-Reservoir-sampling-oror-Prove-step-by-step-oror-Image

```python
class Solution:

    def __init__(self, head: Optional[ListNode]):
        self.nodes = []
        while head:
            self.nodes.append(head.val)
            head = head.next
    def getRandom(self) -> int:
        return random.choice(self.nodes)
```

### 27 817. Linked List Components

```python
class Solution:
    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:
        s = set(nums)
        connected = False
        count = 0
        while head:
            if head.val in s and not connected:
                count += 1
                connected = True
            elif not head.val in s and connected:
                connected = False
            head = head.next
        return count
```

### 29 925. Long Pressed Name

```python
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        def getFrequencyArray(name):
            arr = []
            i = 0
            count = 1
            while i + 1 < len(name):
                if name[i] == name[i + 1]:
                    count += 1
                else:
                    arr.append([name[i], count])
                    count = 1
                i += 1
            if arr and name[-1] == arr[-1][0]:
                arr[-1][1] += 1
            else:
                arr.append([name[-1], 1])
            return arr

        nameArr = getFrequencyArray(name)
        typedArr = getFrequencyArray(typed)
        if (len(nameArr) != len(typedArr)):
            return False
        for i in range(len(nameArr)):
            if nameArr[i][0] != typedArr[i][0] or nameArr[i][1] > typedArr[i][1]:
                return False
        return True
```

### 30 859. Buddy Strings

```python
class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        # if lengths are different, then must be false
        if len(s) != len(goal):
            return False
        # If s and goal are same, then A must have duplicate character
        if s == goal:
            seen = set()
            for a in s:
                if a in seen:
                    return True
                seen.add(a)
            return False

        pair = []
        # when s and goal are not same
        for a, b in zip(s, goal):
            if a != b:
                pair.append((a, b))
            if len(pair) > 2:
                return False

        return len(pair) == 2 and pair[0] == pair[1][::-1]
```

dfs

################################################## Binary Search #########################################################

### 69. Sqrt(x)

#### binary search

template, why return r or l - 1?
there are 2 returns, one is find the m integer, another is trucated, the floor of a float number,
when l > r jump out of the loop, then r goes to the floored number, l goes to the ceiled number.

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            m = l + (r - l) // 2
            if m * m < x:
                l = m + 1
            elif m * m > x:
                r = m - 1
            else:
                return m
        return r # l - 1
```

### 34. Find First and Last Position of Element in Sorted Array

persistant with l <= r template

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binary_right(nums, target):
            n = len(nums)
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > target:
                    r = m - 1
                else:
                    l = m + 1
            return r if r >= 0 and nums[r] == target else -1
        def binary_left(nums, target):
            n = len(nums)
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] < target:
                    l = m + 1
                else:
                    r = m - 1
            return l if l < n and nums[l] == target else -1
        return [binary_left(nums, target), binary_right(nums, target)]
```

### 441. Arranging Coins

```python
class Solution:
    def arrangeCoins(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            m = l + (r - l) // 2
            if m * (m + 1) // 2 > n:
                r = m - 1
            else:
                l = m + 1
        return l - 1
```

### 1871. Jump Game VII

```python
class Solution:
    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:
        q, farthest = deque([0]), 0
        while q:
            i = q.popleft()
            start = max(i + minJump, farthest + 1)
            for j in range(start, min(i + maxJump + 1, len(s))):
                if s[j] == '0':
                    if j == len(s) - 1:
                        return True
                    q.append(j)
            farthest = i + maxJump
        return False
```

## 3 stock price

