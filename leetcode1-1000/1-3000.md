### 1. Two Sum

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i, v in enumerate(nums):
            res = target - v
            if res in d:
                return [d[res], i]
            d[v] = i
```

### 2. Add Two Numbers

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        carry = 0
        while l1 or l2:
            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry
            p.next = ListNode(val % 10)
            if l1: l1 = l1.next
            if l2: l2 = l2.next
            p = p.next
            carry = val // 10
        if carry: p.next = ListNode(carry)
        return dummy.next
```

### 3. Longest Substring Without Repeating Characters

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res, l, d = 0, 0, {}
        for r, v in enumerate(s):
            if v in d:
                l = max(l, d[v] + 1)
            res = max(res, r - l + 1)
            d[v] = r
        return res
```

### 4. Median of Two Sorted Arrays

- https://www.youtube.com/watch?v=LPFhl65R7ww&t=1224s
- https://www.youtube.com/watch?v=q6IEA26hvXc

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        A, B, total = nums1, nums2, len(nums1) + len(nums2)
        half = total // 2
        if len(A) > len(B): A, B = B, A
        lengthA, lengthB = len(A), len(B)
        l, r = 0, lengthA - 1
        while True:
            i = (l + r) // 2
            j = half - i - 2
            leftA = A[i] if i >= 0 else -inf
            rightA = A[i + 1] if i + 1 < lengthA else inf
            leftB = B[j] if j >= 0 else -inf
            rightB = B[j + 1] if j + 1 < lengthB else inf
            if leftA <= rightB and leftB <= rightA:
                if total % 2:
                    return min(rightA, rightB)
                return (max(leftA, leftB) + min(rightA, rightB)) / 2
            elif leftA > rightB:
                r = i - 1
            else:
                l = i + 1
```

### 5. Longest Palindromic Substring

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        def subLongestPalindrome(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1: r]

        res = ''
        for i in range(len(s)):
            res = max(res, subLongestPalindrome(i, i), subLongestPalindrome(i, i + 1), key = len)
        return res
```

### 6. Zigzag Conversion

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows ==  1 or numRows >= len(s):
            return s
        bucket, flip, row = [[] for i in range(numRows)], -1, 0
        for c in s:
            bucket[row].append(c)
            if row == numRows - 1 or row == 0:
                flip *= -1
            row += flip
        for i, arr in enumerate(bucket):
            bucket[i] = ''.join(arr)
        return ''.join(bucket)
```

### 7. Reverse Integer

```python
class Solution:
    def reverse(self, x: int) -> int:
        def reversePositiveNum(x):
            res = 0
            while x:
                res = res * 10 + x % 10
                x //= 10
            return res
        res = reversePositiveNum(x) if x > 0 else -reversePositiveNum(-x)
        return res if -2 ** 31 <= res <= 2 ** 31 + 1 else 0
```

### 8. String to Integer (atoi)

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        res, sign, s = '', ['+', '-'], s.strip()
        for i, c in enumerate(s):
            if i == 0 and c in sign or c.isnumeric():
                res += c
            else:
                break
        if not res or res in sign:
            return 0
        return min(max(int(res), -2 ** 31), 2 ** 31 - 1)
```

### 9. Palindrome Number

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        def reversePositiveNum(x):
            res = 0
            while x:
                res = res * 10 + x % 10
                x //= 10
            return res
        return reversePositiveNum(x) == x
```

### 10. Regular Expression Matching

- https://www.youtube.com/watch?v=HAA8mgxlov8

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lengthS, lengthP = len(s), len(p)
        @lru_cache(None)
        def dfs(i, j):
            if i >= lengthS and j >= lengthP:
                return True
            if j >= lengthP:
                return False
            match = i < lengthS and (s[i] == p[j] or p[j] == '.')
            if j + 1 < lengthP and p[j + 1] == '*': # check *, 0 or more
                return dfs(i, j + 2) or (match and dfs(i + 1, j))
            return dfs(i + 1, j + 1) if match else False # check match or not if no *
        return dfs(0, 0)
```

### 11. Container With Most Water

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r, res = 0, len(height) - 1, 0
        while l < r:
            res = max(res, min(height[l], height[r]) * (r - l))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return res
```

### 12. Integer to Roman

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        numbers = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
        res = ''
        for i, n in enumerate(numbers):
            res += num // n * symbols[i]
            num %= n
        return res
```

### 13. Roman to Integer

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {
            'I': 1,
            'V': 5,
            'X': 10,
            'L': 50,
            'C': 100,
            'D': 500,
            'M': 1000
        }
        res = d[s[0]]
        for i in range(1, len(s)):
            res += d[s[i]]
            if d[s[i]] > d[s[i - 1]]:
                res -= 2 * d[s[i - 1]]
        return res
```

### 14. Longest Common Prefix

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        res = strs[0]
        for item in strs:
            while not item.startswith(res):
                res = res[: -1]
        return res
```

#### Tag: Trie

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True
        
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        trie = Trie()
        for word in strs:
            trie.insert(word)
            
        root = trie.root
        res = ''
        while root:
            if len(root.children) > 1 or root.endOfWord:
                break
            c = list(root.children)[0]
            root = root.children[c]
            res += c
        return res
```

### 15. 3Sum

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res, n = set(), len(nums)
        for i in range(n):
            l, r = i + 1, n - 1
            while l < r:
                three = nums[i] + nums[l] + nums[r]
                if three > 0:
                    r -= 1
                elif three < 0:
                    l += 1
                else:
                    res.add((nums[i], nums[l], nums[r]))
                    l += 1
                    r -= 1
        return res
```

### 16. 3Sum Closest

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        res, n = float('inf'), len(nums)
        nums.sort()
        for i in range(n):
            l, r = i + 1, n - 1
            while l < r:
                three = nums[i] + nums[l] + nums[r]
                if abs(target - three) < abs(target - res):
                    res = three
                if three > target:
                    r -= 1
                else:
                    l += 1
        return res
```

### 17. Letter Combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        d = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res = ['']
        for n in digits:
            letters = d[n]
            ans = []
            for item in res:
                for c in letters:
                    ans.append(item + c)
            res = ans
        return res if digits else []
```

### 18. 4Sum

```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        s, n = set(), len(nums)
        nums.sort()
        for i in range(n):
            for j in range(i + 1, n):
                l, r = j + 1, n - 1
                while l < r:
                    four = nums[i] + nums[j] + nums[l] + nums[r]
                    if four == target:
                        s.add((nums[i], nums[j], nums[l], nums[r]))
                        l += 1
                        r -= 1
                    elif four < target:
                        l += 1
                    else:
                        r -= 1
        return s
```

### 19. Remove Nth Node From End of List

```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = slow = fast = ListNode()
        dummy.next = head
        for i in range(n + 1):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```

### 20. Valid Parentheses

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack, valid = [], ['{}', '[]', '()']
        for c in s:
            if stack and any([c == valid[i][1] and stack[-1] == valid[i][0] for i in range(len(valid))]):
                stack.pop()
            else:
                stack.append(c)
        return not stack
```

### 21. Merge Two Sorted Lists

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        p = dummy = ListNode()
        while list1 and list2:
            if list1.val < list2.val:
                p.next = ListNode(list1.val)
                list1 = list1.next
            else:
                p.next = ListNode(list2.val)
                list2 = list2.next
            p = p.next
        p.next = list1 if list1 else list2
        return dummy.next
```

### 22. Generate Parentheses

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack, res = [], []
        def backtrack(open, close):
            if open == close == n:
                res.append(''.join(stack))
                return
            if open < n:
                stack.append('(')
                backtrack(open + 1, close)
                stack.pop()
            if close < open:
                stack.append(')')
                backtrack(open, close + 1)
                stack.pop()
        backtrack(0, 0)
        return res
```

### 23. Merge k Sorted Lists

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        dummy = p = ListNode()
        minHeap = []
        for head in lists:
            while head:
                heappush(minHeap, head.val)
                head = head.next
        while minHeap:
            val = heappop(minHeap)
            p.next = ListNode(val)
            p = p.next
        return dummy.next
```

### 24. Swap Nodes in Pairs

```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = dummy = ListNode(0)
        prev.next, curr = head, head
        total = 0
        while head:
            total += 1
            head = head.next

        def reverseOnePair():
            nxt = curr.next
            curr.next, nxt.next, prev.next = nxt.next, prev.next, nxt
        for i in range(total // 2):
            reverseOnePair()
            prev, curr = curr, curr.next
        return dummy.next
```

### 25. Reverse Nodes in k-Group

```python
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        prev = dummy = ListNode(0)
        prev.next, curr = head, head
        total = 0
        while head:
            total += 1
            head = head.next
            
        def reverseOnePair():
            nxt = curr.next
            curr.next, nxt.next, prev.next = nxt.next, prev.next, nxt
        for i in range(total // k):
            for j in range(k - 1):
                reverseOnePair()
            prev, curr = curr, curr.next
        return dummy.next
```

### 26. Remove Duplicates from Sorted Array

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        k = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[i - 1]:
                nums[k] = nums[i]
                k += 1
        return k
```

### 27. Remove Element

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k, r = 0, len(nums) - 1
        while k <= r:
            if nums[k] == val:
                nums[k] = nums[r]
                r -= 1
            else:
                k += 1
        return k
```

### 28. Find the Index of the First Occurrence in a String

- Robin Karp: rolling hash

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        n, pattern = len(needle), hash(needle)
        for i in range(len(haystack)):
            if hash(haystack[i:i+n]) == pattern:
                return i
        return -1
```

### 29. Divide Two Integers

```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        if (dividend == -2 ** 31 and divisor == -1): return 2 ** 31 - 1 # max value overflow
        a, b, res = abs(dividend), abs(divisor), 0
        for x in range(32)[::-1]:
            if (a >> x) - b >= 0: # first: 1010 >> 1 = 101 > 11, second: 100 >> 0 = 100 > 11
                res += 1 << x # first: 0 + 1 << 1 = 2, second: 2 + 1 << 0 = 2 + 1 = 3
                a -= b << x # first: 1010 - 11 << 1 = 10 - 6 = 4, second: 100 - 11 << 0 = 100 - 11 = 1, stop
        return res if (dividend > 0) == (divisor > 0) else -res
```

### 30. Substring with Concatenation of All Words

```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        ans, n, m, words  = [], len(words), len(words[0]), Counter(words)
        for i in range(len(s) - n * m + 1):
            tmp, cnt = Counter(), 0
            for j in range(i, i + n * m, m):
                w = s[j: j + m]
                if w in words:
                    tmp[w] += 1
                    cnt += 1
                    if tmp[w] > words[w]: 
                        break
                    if cnt == n:
                        ans.append(i)
        return ans
```

### 32. Longest Valid Parentheses

https://www.youtube.com/watch?v=q56S5NIqjdE

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        stack, res = [-1], 0 # edge cases of s = "()"
        for i in range(len(s)):
            if s[i] == "(": # prepare for finding the max
                stack.append(i)
            else:
                stack.pop()
                if not stack:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])
        return res
```

### 33. Search in Rotated Sorted Array

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return m
            if nums[m] >= nums[l]:
                if (nums[l] <= target < nums[m]):
                    r = m - 1
                else:
                    l = m + 1
            else:
                if (nums[m] < target <= nums[r]):
                    l = m + 1
                else:
                    r = m - 1
        return -1
```
### 34. Find First and Last Position of Element in Sorted Array

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        def binary_right(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > target:
                    r = m - 1
                else:
                    l = m + 1
            return r if r >= 0 and nums[r] == target else -1
        def binary_left(nums, target):
            l, r = 0, n - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] < target:
                    l = m + 1
                else:
                    r = m - 1
            return l if l < n and nums[l] == target else -1
        return [binary_left(nums, target), binary_right(nums, target)]
```

### 35. Search Insert Position

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        return bisect_left(nums, target)
```

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] < target:
                l = m + 1
            elif nums[m] > target:
                r = m - 1
            else:
                return m
        return l
```

### 36. Valid Sudoku

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        rows, cols, squres = defaultdict(set), defaultdict(set), defaultdict(set)
        for r in range(len(board)):
            for c in range(len(board[0])):
                if board[r][c] in (rows[r] | cols[c] | squres[(r // 3, c // 3)]):
                    return False
                if board[r][c] != '.':
                    rows[r].add(board[r][c])
                    cols[c].add(board[r][c])
                    squres[(r // 3, c // 3)].add(board[r][c])
        return True
```

### 37. Sudoku Solver

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols, squares, visit = defaultdict(set), defaultdict(set), defaultdict(set), deque([])
        for i in range(9):
            for j in range(9):
                if board[i][j] != ".":
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    squares[(i // 3, j // 3)].add(board[i][j])
                else:
                    visit.append((i,j))

        def dfs():
            if not visit:
                return True

            r, c = visit[0]
            square, numbers = (r // 3, c // 3), {'1','2','3','4','5','6','7','8','9'}
            for n in numbers: # try 9 ways
                if n not in (rows[r] | cols[c] | squares[square]):
                    board[r][c] = n
                    rows[r].add(n)
                    cols[c].add(n)
                    squares[square].add(n)
                    visit.popleft()
                    if dfs(): # find 1 way
                        return True
                    else: # backtrack
                        board[r][c] = "."
                        rows[r].discard(n)
                        cols[c].discard(n)
                        squares[square].discard(n)
                        visit.appendleft((r,c))
            return False # not find
        dfs()
```

### 38. Count and Say

```python
class Solution:
    def countAndSay(self, n: int) -> str:
        if n == 1:
            return '1'
        preString= self.countAndSay(n-1)
        count, res, length = 1, '', len(preString)
        for i in range(length):
            if i < length - 1 and preString[i] == preString[i + 1]:
                count += 1
            else:
                res += str(count) + preString[i]
                count = 1
        return res
```

### 39. Combination Sum

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res, n = [], len(candidates)
        def backtrack(curr, ans, idx):
            if curr > target:
                return
            if curr == target:
                res.append(ans)
            for i in range(idx, n):
                backtrack(curr + candidates[i], [candidates[i]] + ans, i)
        backtrack(0, [], 0)
        return res
```

### 40. Combination Sum II

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        res = []
        def backtrack(nums, ans, curr):
            if curr > target:
                return
            if curr == target:
                res.append(ans)
            for i in range(len(nums)):
                if i > 0 and nums[i - 1] == nums[i]:
                    continue
                backtrack(nums[i + 1: ], ans + [nums[i]], curr + nums[i])
        backtrack(candidates, [], 0)
        return res
```

### 41. First Missing Positive

# set
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        s = set(nums)
        for i in range(1, len(nums) + 2):
            if i not in s:
                return i
```

### array index
```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        # 3 passes
        n = len(nums)
        for i in range(n): # find negative
            if nums[i] < 0:
                nums[i] = 0
        for i in range(n): # sign positive to negative
            val = abs(nums[i])
            if 1 <= val <= n:
                if nums[val - 1] > 0:
                    nums[val - 1] *= -1
                elif nums[val - 1] == 0: # handle 0, sign to negative out of [1, len(nums)]
                    nums[val - 1] = -1 * (n + 1)
        for i in range(1, n + 1): # find first positive or 0
            if nums[i - 1] >= 0:
                return i
        return len(nums) + 1
```

### 42. Trapping Rain Water

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        l, r, res = 0, len(height) - 1, 0
        leftMax, rightMax = height[l], height[r]
        while l < r:
            if leftMax < rightMax:
                l += 1
                leftMax = max(leftMax, height[l])
                res += leftMax - height[l]
            else:
                r -= 1
                rightMax = max(rightMax, height[r])
                res += rightMax - height[r]
        return res
```

### 43. Multiply Strings

```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        def str_to_num(n):
            res = 0
            for i in range(len(n)):
                res = res * 10 + ord(n[i]) - ord('0')
            return res
        res = str_to_num(num1) * str_to_num(num2)
        # convert to string, remember to reverse the result 
        ans = '0' 
        while res:
            ans = (chr(ord('0') + res % 10)) + ans
            res //= 10 
        return ans[:-1] if len(ans) > 1 else ans
```

### 44. Wildcard Matching

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        R, C = len(s), len(p)
        dp = [[False for j in range(C + 1)] for i in range(R + 1)]
        dp[0][0] = True
        for j in range(1, C + 1):
            if p[j - 1] == "*" and dp[0][j - 1]:
                dp[0][j] = True
        
        for i in range(1, R + 1):
            for j in range(1, C + 1):
                if p[j-1] == s[i-1] or p[j-1] == "?":
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == "*":
                    dp[i][j] = dp[i-1][j] or dp[i][j-1] or dp[i-1][j-1]
        return dp[-1][-1]
```

### 45. Jump Game II

#### sliding window

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        res, l, r = 0, 0, 0
        while r < len(nums) - 1:
            furthest = 0
            for i in range(l, r + 1):
                furthest = max(furthest, nums[i] + i)
            res += 1
            l += 1
            r = furthest
        return res
```

### 46. Permutations

#### backtrack

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, res):
            if not nums:
                res.append(ans[::])
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, res)
                ans.pop()
            return res
        return backtrack(nums, [], [])
```

### 47. Permutations II

### same as: 46
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, s):
            if not nums:
                s.add(tuple(ans[::]))
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, s)
                ans.pop()
            return s
        return backtrack(nums, [], set())
```

### 48. Rotate Image

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def backtrack(nums, ans, s):
            if not nums:
                s.add(tuple(ans[::]))
            for i in range(len(nums)):
                ans.append(nums[i])
                backtrack(nums[:i] + nums[i+1:], ans, s)
                ans.pop()
            return s
        return backtrack(nums, [], set())
```

### 49. Group Anagrams

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)
        for s in strs:
            res = ''.join(sorted(list(s)))
            d[res].append(s)
        return list(d.values())
```

### 50. Pow(x, n)

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def helper(x, n):
            if x == 0:
                return 0
            if n == 0:
                return 1
            res = helper(x, n // 2)
            res *= res
            return res * x if n % 2 else res
        res = helper(x, abs(n))
        return res if n >= 0 else 1 / res
```
### 51. N-Queens

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        col, posDiag, negDiag = set(), set(), set()
        res, board = [], [['.'] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                res.append([''.join(row) for row in board])
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue
                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                board[r][c] = 'Q'
                backtrack(r + 1)
                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
                board[r][c] = '.'
        backtrack(0)
        return res
```

### 52. N-Queens II

```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        col, posDiag, negDiag = set(), set(), set()
        res, board = 0, [['.'] * n for i in range(n)]
        def backtrack(r):
            if r == n:
                nonlocal res
                res += 1
                return

            for c in range(n):
                if c in col or (r + c) in posDiag or (r - c) in negDiag:
                    continue
                col.add(c)
                posDiag.add(r + c)
                negDiag.add(r - c)
                backtrack(r + 1)
                col.remove(c)
                posDiag.remove(r + c)
                negDiag.remove(r - c)
        backtrack(0)
        return res
```

### 53. Maximum Subarray (dp, 978)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp, res = [nums[0]] * n, nums[0]
        for i in range(1, n):
            dp[i] = max(nums[i], dp[i - 1] + nums[i])
            res = max(res, dp[i])
        return res
```

### 54. Spiral Matrix

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        while matrix:
            res.extend(matrix.pop(0))
            matrix = list(zip(*matrix))[::-1]
        return res
```

### 55. Jump Game

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        res, n = 0, len(nums)
        for i in range(n):
            res = max(res, i + nums[i])
            if res >= n - 1:
                return True
            elif res <= i:
                return False
```

### 56. Merge Intervals (57)

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= res[-1][1]:
                res[-1][1] = max(end, res[-1][1])
            else:
                res.append([start, end])
        return res
```

### 57. Insert Interval (56)

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        intervals.append(newInterval)
        intervals.sort()
        res = [intervals[0]]
        for start, end in intervals[1:]:
            if start <= res[-1][1]:
                res[-1][1] = max(end, res[-1][1])
            else:
                res.append([start, end])
        return res
```

### 58. Length of Last Word

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        return len(s.split()[-1])
```

### 59. Spiral Matrix II

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        A, lo = [], n*n+1
        while lo > 1:
            lo, hi = lo - len(A), lo
            A = [range(lo, hi)] + list(zip(*A[::-1]))
        return A
```

### 60. Permutation Sequence 

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        res, nums = '', list(range(1, n + 1))
        for i in range(1, n + 1):
            index = 0
            cnt = factorial(n - i)
            while k > cnt:
                index += 1
                k -= cnt
            res += str(nums[index])
            nums.pop(index)
        return res
```

### 61. Rotate List
 
```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head: return head
        #connect tail to head
        cur, length = head, 1
        while cur.next:
            cur = cur.next
            length+=1 
        cur.next = head

        # move to new head
        k = length - (k % length)
        while k > 0:
            cur=cur.next
            k-=1

        #disconnect and return new head
        newhead = cur.next
        cur.next = None
        return newhead
```

### 62. Unique Paths

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # # method 1: dp
        '''
        ROWS, COLS = m, n
        dp = [[1] * COLS for i in range(ROWS)]
        for i in range(1, ROWS):
            for j in range(1, COLS):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
        '''
        
        # method 2: dfs
        '''
        @lru_cache(None)
        def dfs(row, col):
            if row == m or col == n:
                return 0
            if row == m - 1 and col == n - 1:
                return 1
            return dfs(row + 1, col) + dfs(row, col + 1)
        return dfs(0, 0)
        '''

        ### method 3: math
        return factorial(m + n - 2) // (factorial(n - 1) * factorial(m - 1))
```

### 63. Unique Paths II
 
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # method 1: dfs + memo
        '''
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        @lru_cache(None)
        def dfs(row, col):
            if row == m or col == n or obstacleGrid[row][col]:
                return 0
            if row == m - 1 and col == n - 1:
                if obstacleGrid[row][col]:
                    return 0
                return 1
            return dfs(row + 1, col) + dfs(row, col + 1)
        return dfs(0, 0)
        '''
        
        # method 2: dp
        ROWS, COLS = len(obstacleGrid), len(obstacleGrid[0])
        dp = [[1] * COLS for i in range(ROWS)]
        if obstacleGrid[0][0]: return 0
        for j in range(1, COLS):
            dp[0][j] = 0 if obstacleGrid[0][j] else dp[0][j - 1]
        for i in range(1, ROWS):
            dp[i][0] = 0 if obstacleGrid[i][0] else dp[i - 1][0]
        for i in range(1, ROWS):
            for j in range(1, COLS):
                if obstacleGrid[i][j]:
                    dp[i][j] = 0
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[-1][-1]
```

### 64. Minimum Path Sum

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        R, C, first = len(grid), len(grid[0]), grid[0][0]
        # state
        dp = [[first] * C for i in range(R)]
        # init rows
        for j in range(1, C):
            dp[0][j] = dp[0][j - 1] + grid[0][j]
        # init cols
        for i in range(1, R):
            dp[i][0] = dp[i - 1][0] + grid[i][0]
        # top-down
        for i in range(1, R):
            for j in range(1, C):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
        return dp[-1][-1]
```

### 65. Valid Number

```python
class Solution:
    def isNumber(self, s: str) -> bool:
        # s = s.strip()
        met_dot = met_e = met_digit = False
        for i, char in enumerate(s):
            if char in ['+', '-']:
                if i > 0 and s[i-1].lower() != 'e':
                    return False
            elif char == '.':
                if met_dot or met_e: return False
                met_dot = True
            elif char.lower() == 'e':
                if met_e or not met_digit:
                    return False
                met_e, met_digit = True, False
            elif char.isdigit():
                met_digit = True
            else:
                return False
        return met_digit
```

### 66. Plus One

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        carry, digits[-1] = 0, digits[-1] + 1
        for i in range(len(digits) - 1, -1, -1):
            res = carry + digits[i]
            digits[i] = res % 10
            carry = res // 10
        return [carry] + digits if carry else digits
```

### 67. Add Binary

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry, i, j, res = 0, len(a) - 1, len(b) - 1, ''
        while i >= 0 or j >= 0:
            ans = carry
            if i >= 0:
                ans += ord(a[i]) - ord('0')
            if j >= 0:
                ans += ord(b[j]) - ord('0')
            i, j = i - 1, j - 1
            carry = 1 if ans > 1 else 0
            res = str(ans % 2) + res
        if carry:
            res = str(carry) + res
        return res
```

### 68. Text Justification

```python
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        res, i, width, cur_line = [], 0, 0, []
        while i < len(words):
            cur_word = words[i]
            if width + len(cur_word) <= maxWidth:
                cur_line.append(cur_word)
                width += len(cur_word) + 1
                i += 1
            else:
                spaces = maxWidth - width + len(cur_line) # check how many spaces
                added, j = 0, 0
                while added < spaces: # put the spaces between the words evenly
                    if j >= len(cur_line) - 1:
                        j = 0
                    cur_line[j] += ' '
                    added, j = added + 1, j + 1
                res.append("".join(cur_line))
                cur_line, width = [], 0

        # handle last line
        for word in range(len(cur_line) - 1):
            cur_line[word] += ' '
        cur_line[-1] += ' ' * (maxWidth - width + 1)
        res.append(''.join(cur_line))
        return res
```

### 69. Sqrt(x)

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l <= r:
            m = l + (r - l) // 2
            if m * m < x:
                l = m + 1
            elif m * m > x:
                r = m - 1
            else:
                return m
        return r
```

### 70. Climbing Stairs

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        first, second = 1, 2
        for i in range(3, n + 1):
            second, first = second + first, second
        return second if n >= 2 else first
```

### 71. Simplify Path

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        stack = []
        for item in path.split('/'):
            if item in ('', '.'):
                continue
            if item == '..':
                if stack:
                    stack.pop()
            else:
                stack.append(item)
        return '/' + '/'.join(stack)
```

### 72. Edit Distance

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1, len2 = len(word1), len(word2)
        dp = [[0] * (len2 + 1) for i in range(len1 + 1)]
        for i in range(1, len1 + 1): dp[i][0] = i
        for j in range(1, len2 + 1): dp[0][j] = j
        for i in range(1, len1 + 1):
            for j in range(1, len2 + 1):
                dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, 
                    dp[i - 1][j - 1] if word1[i - 1] == word2[j - 1] else dp[i - 1][j - 1] + 1)
        return dp[-1][-1]
```

### 73. Set Matrix Zeroes

```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        R, C, row, col = len(matrix), len(matrix[0]), set(), set()
        for r in range(R):
            for c in range(C):
                if matrix[r][c] == 0:
                    row.add(r)
                    col.add(c)
        for r in range(R):
            for c in range(C):
                if r in row or c in col:
                    matrix[r][c] = 0
```

### 74. Search a 2D Matrix

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        def search(nums, n):
            l, r = 0, len(nums) - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] > n:
                    r = m - 1
                elif nums[m] < n:
                    l = m + 1
                else:
                    return True
            return False
        # check column if not exist, leave it row, row will return false
        # if find, leave it to row, if exist, it will become true
        l, r = 0, len(matrix) - 1
        while l <= r:
            m = l + (r - l) // 2
            if matrix[m][0] > target:
                r = m - 1
            else:
                l = m + 1
            
        if search(matrix[l - 1], target):
            return True
        return False
```

### 75. Sort Colors

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] > nums[j]:
                    nums[i], nums[j] = nums[j], nums[i]
```
Follow up: Could you come up with a one-pass algorithm using only constant extra space?

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i, l, r = 0, 0, len(nums) - 1
        while i <= r:
            if nums[i] == 0:
                nums[i], nums[l] = nums[l], nums[i]
                l += 1
                i += 1
            elif nums[i] == 2:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            else:
                i += 1
```

### 76. Minimum Window Substring

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        res, l, tCounter, window = "", 0, Counter(t), Counter()
        for r, c in enumerate(s):
            window[c] += 1
            while window >= tCounter:
                if res == "" or r - l + 1 < len(res):
                    res = s[l: r + 1]
                window[s[l]] -= 1
                l += 1
        return res
```
## 208. Implement Trie (Prefix Tree)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return cur.endOfWord

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if c not in cur.children:
                return False
            cur = cur.children[c]
        return True
```

## 648. Replace Words

### set

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        d = set(dictionary)
        def replace(word):
            for i in range(1, len(word)):
                if word[:i] in d:
                    return word[:i]
            return word
        return " ".join(map(replace, sentence.split()))
```

### Trie

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.endOfWord = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.endOfWord = True

    def replace(self, word: str) -> bool:
        cur = self.root
        for i, c in enumerate(word):
            if c not in cur.children:
                break
            cur = cur.children[c]
            if cur.endOfWord:
                return word[: i + 1]
        return word

class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for prefix in dictionary:
            trie.insert(prefix)
        return " ".join(map(trie.replace, sentence.split()))
```

662. Maximum Width of Binary Tree

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        q, res = deque([(root, 1)]), 0
        while q:
            left, right = q[0][1], q[-1][1]
            res = max(res, right - left + 1)
            for i in range(len(q)):
                node, index = q.popleft()
                if node.left: q.append((node.left, 2 * index))
                if node.right: q.append((node.right, 2 * index + 1))
        return res
```

### 1268. Search Suggestions System (Trie)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.words = []
        self.n = 0
        
class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children: 
                cur.children[c] = TrieNode()
            cur = cur.children[c] 
            if cur.n < 3:
                cur.words.append(word)
                cur.n += 1
        
    def find(self, prefix):
        cur = self.root
        for c in prefix:
            if c not in cur.children: 
                return ''
            cur = cur.children[c] 
        return cur.words
            
class Solution:
    def suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]:
        products.sort()
        trie = Trie()
        for word in products: 
            trie.insert(word)
        ans, cur = [], ''
        for c in searchWord:
            cur += c 
            ans.append(trie.find(cur))
        return ans    
```


1631. Path With Minimum Effort

```python
class Solution:
    def minimumEffortPath(self, heights: List[List[int]]) -> int:
        R, C = len(heights), len(heights[0])
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        res, minHeap, visited = 0, [(0, 0, 0)], set([(0, 0)])
        while minHeap:
            k, r, c = heappop(minHeap)
            res = max(res, k)
            if (r, c) == (R - 1, C - 1):
                return res
            visited.add((r, c))
            for dr, dc in directions:
                row, col = dr + r, dc + c
                if 0 <= row < R and 0 <= col < C and (row, col) not in visited:
                    new_k = abs(heights[r][c] - heights[row][col])
                    heappush(minHeap, (new_k, row, col))
```

2731. Movement of Robots

```python
class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        for i, n in enumerate(nums):
            if s[i] == 'R':
                nums[i] += d
            else:
                nums[i] -= d

        nums.sort()
        res = [nums[i] - nums[i - 1] for i in range(1, len(nums))]
        n, ans = len(res), 0
        for i in range(n):
            ans += (i + 1) * (n - i) * res[i]
        return ans % (10 ** 9 + 7)
```

### 剑指 Offer 38. 字符串的排列 (permunation)
输入一个字符串，打印出该字符串中字符的所有排列。

 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 

示例:

输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
 

限制：

1 <= s 的长度 <= 8

```python
class Solution:
    def permutation(self, s: str) -> List[str]:
        def backtrack(letters, ans, res):
            if not letters:
                res.append(''.join(ans[::]))
            s = set()
            for i in range(len(letters)):
                if letters[i] in s: continue
                s.add(letters[i])
                ans.append(letters[i])
                backtrack(letters[:i] + letters[i+1:], ans, res)
                ans.pop()
            return res
        return backtrack(s, [], [])
```

### 560. Subarray Sum Equals K

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        d, res, presum = {0: 1}, 0, 0
        for n in nums:
            presum += n
            prev_vals = presum - k
            if prev_vals in d:
                res += d[prev_vals]
            d[presum] = d.get(presum, 0) + 1
        return res
```

### 213. House Robber II

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def rob_a_line(nums):
            nums, prev = [0] + nums, 0
            for i in range(2, len(nums)):
                prev = max(prev, nums[i - 2])
                nums[i] += prev
            return max(nums[-2:])
        if len(nums) == 1:
            return nums[0]
        return max(rob_a_line(nums[1: ]), rob_a_line(nums[: -1]))
```

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n, nums1, nums2 =len(nums), [0] + nums[: -1], [0] + nums[1: ]
        if n == 1:
            return nums[0]
        for i in range(2, n):
            nums1[i] = max(nums1[i - 1], nums1[i - 2] + nums1[i])
            nums2[i] = max(nums2[i - 1], nums2[i - 2] + nums2[i])
        return max(nums1[-2: ] + nums2[-2: ]) 
```

### 540. Single Element in a Sorted Array

```python
```

### 978. Longest Turbulent Subarray

```python
class Solution:
    def maxTurbulenceSize(self, arr: List[int]) -> int:
        n, res = len(arr), 1
        dp1, dp2 = [1] * n, [1] * n
        for i in range(0, n - 1):
            if i % 2:
                if arr[i] > arr[i + 1]:
                    dp1[i + 1] += dp1[i]
                elif arr[i] < arr[i + 1]:
                    dp2[i + 1] += dp2[i]
            else:
                if arr[i] < arr[i + 1]:
                    dp1[i + 1] += dp1[i]
                elif arr[i] > arr[i + 1]:
                    dp2[i + 1] += dp2[i]
            res = max(res, dp1[i + 1], dp2[i + 1])
        return res
```

### 537. Complex Number Multiplication

```python
class Solution:
    def complexNumberMultiply(self, num1: str, num2: str) -> str:
        a1, a2 = map(int, num1[:-1].split('+'))
        b1, b2 = map(int, num2[:-1].split('+'))
        return '%d+%di' % (a1 * b1 - a2 * b2, a1 * b2 + a2 * b1)
```

### 1072. Flip Columns For Maximum Number of Equal Rows

```python
class Solution:
    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:
        d = defaultdict(int)
        for row in matrix:
            d[tuple(row)] += 1
            d[tuple([1 - c for c in row])] += 1
        return max(d.values())
```

### 1248. Count Number of Nice Subarrays

```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        length, window = len(nums), []
        for i, n in enumerate(nums): # put all odd index to window
            if n % 2:
                window.append(i)
        if len(window) < k: # not meet conditions
            return 0
        window = [-1] + window + [length] # padding head and tail to make calc easier
        res = 0
        for i in range(1, len(window) - k):
            res += (window[i] - window[i - 1]) * (window[i + k] - window[i + k - 1]) # core combinations
        return res
```

### 131. Palindrome Partitioning

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def isPanlindrome(s):
            return s == ''.join(reversed(list(s)))

        res, ans, n = [], [], len(s)
        def backtrack(i):
            if i >= n:
                res.append(ans[::])
                return
            for j in range(i, n):
                if isPanlindrome(s[i: j + 1]):
                    ans.append(s[i: j + 1])
                    backtrack(j + 1)
                    ans.pop()
        backtrack(0)
        return res
```

### 132. Palindrome Partitioning II

```python
class Solution:
    def minCut(self, s: str) -> int:
        g, n = defaultdict(set), len(s)
        def helper(l, r):
            while l >= 0 and r < n and s[l] == s[r]:
                g[l].add(r)
                l -= 1
                r += 1
        for i in range(n):
            helper(i, i)
            helper(i, i + 1)
        
        @lru_cache(None)
        def dfs(i):
            if i >= n:
                return 0
            ans = n
            for j in range(i, n):
                if j in g[i]:
                    ans = min(ans, dfs(j + 1) + 1)
            return ans
        return dfs(0) - 1
```